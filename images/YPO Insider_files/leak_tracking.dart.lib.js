// Generated by DDC, the Dart Development Compiler (to JavaScript).
// Version: 3.3.1 (stable) (Wed Mar 6 13:09:19 2024 +0000) on "macos_arm64"
// Module: packages/leak_tracker/src/leak_tracking/leak_tracking.dart
// Flags: newRuntimeTypes(true), soundNullSafety(true), enableAsserts(true)
define(['dart_sdk', 'packages/leak_tracker/src/leak_tracking/_baseliner.dart', 'packages/leak_tracker/src/leak_tracking/primitives/model.dart', 'packages/leak_tracker/src/leak_tracking/_leak_tracker.dart', 'packages/leak_tracker/src/devtools_integration/_registration.dart', 'packages/leak_tracker/src/leak_tracking/primitives/_dispatcher.dart', 'packages/leak_tracker/src/shared/_primitives.dart', 'packages/leak_tracker/src/shared/shared_model.dart'], (function load__packages__leak_tracker__src__leak_tracking__leak_tracking_dart(dart_sdk, packages__leak_tracker__src__leak_tracking___baseliner$46dart, packages__leak_tracker__src__leak_tracking__primitives__model$46dart, packages__leak_tracker__src__leak_tracking___leak_tracker$46dart, packages__leak_tracker__src__devtools_integration___registration$46dart, packages__leak_tracker__src__leak_tracking__primitives___dispatcher$46dart, packages__leak_tracker__src__shared___primitives$46dart, packages__leak_tracker__src__shared__shared_model$46dart) {
  'use strict';
  const dart_rti = dart_sdk.dart_rti;
  const core = dart_sdk.core;
  const async = dart_sdk.async;
  const _js_helper = dart_sdk._js_helper;
  const dart = dart_sdk.dart;
  const dartx = dart_sdk.dartx;
  const _baseliner = packages__leak_tracker__src__leak_tracking___baseliner$46dart.src__leak_tracking___baseliner;
  const model = packages__leak_tracker__src__leak_tracking__primitives__model$46dart.src__leak_tracking__primitives__model;
  const _leak_tracker = packages__leak_tracker__src__leak_tracking___leak_tracker$46dart.src__leak_tracking___leak_tracker;
  const _registration = packages__leak_tracker__src__devtools_integration___registration$46dart.src__devtools_integration___registration;
  const _dispatcher = packages__leak_tracker__src__leak_tracking__primitives___dispatcher$46dart.src__leak_tracking__primitives___dispatcher;
  const _primitives = packages__leak_tracker__src__shared___primitives$46dart.src__shared___primitives;
  const shared_model = packages__leak_tracker__src__shared__shared_model$46dart.src__shared__shared_model;
  var leak_tracking = Object.create(dart.library);
  dart._checkModuleNullSafetyMode(true);
  dart._checkModuleRuntimeTypes(true);
  var T = {
    LeakProvider: () => (T.LeakProvider = dart.constFn(dart_rti.findType("leak_tracker__src__shared__shared_model|LeakProvider")))(),
    VoidTobool: () => (T.VoidTobool = dart.constFn(dart_rti.findType("core|bool()")))(),
    __Tovoid: () => (T.__Tovoid = dart.constFn(dart_rti.findType("~({className!core|String,context:core|Map<core|String,@>?,library!core|String,object!core|Object})")))(),
    __Tovoid$1: () => (T.__Tovoid$1 = dart.constFn(dart_rti.findType("~({context:core|Map<core|String,@>?,object!core|Object})")))(),
    LeakSummary: () => (T.LeakSummary = dart.constFn(dart_rti.findType("leak_tracker__src__shared__shared_model|LeakSummary")))(),
    LeakType: () => (T.LeakType = dart.constFn(dart_rti.findType("leak_tracker__src__shared__shared_model|LeakType")))(),
    int: () => (T.int = dart.constFn(dart_rti.findType("core|int")))(),
    Leaks: () => (T.Leaks = dart.constFn(dart_rti.findType("leak_tracker__src__shared__shared_model|Leaks")))(),
    ListOfLeakReport: () => (T.ListOfLeakReport = dart.constFn(dart_rti.findType("core|List<leak_tracker__src__shared__shared_model|LeakReport>")))(),
    void: () => (T.void = dart.constFn(dart_rti.findType("~")))(),
    PhaseSettings: () => (T.PhaseSettings = dart.constFn(dart_rti.findType("leak_tracker__src__leak_tracking__primitives__model|PhaseSettings")))(),
    bool: () => (T.bool = dart.constFn(dart_rti.findType("core|bool")))(),
    __Tovoid$2: () => (T.__Tovoid$2 = dart.constFn(dart_rti.findType("~({config:leak_tracker__src__leak_tracking__primitives__model|LeakTrackingConfig,resetIfAlreadyStarted:core|bool})")))(),
    VoidTovoid: () => (T.VoidTovoid = dart.constFn(dart_rti.findType("~()")))(),
    MapOfObject$MapOfString$ObjectTovoid: () => (T.MapOfObject$MapOfString$ObjectTovoid = dart.constFn(dart_rti.findType("~(core|Map<core|Object,core|Map<core|String,core|Object>>)")))(),
    VoidToFutureOfLeakSummary: () => (T.VoidToFutureOfLeakSummary = dart.constFn(dart_rti.findType("async|Future<leak_tracker__src__shared__shared_model|LeakSummary>()")))(),
    VoidToFutureOfLeaks: () => (T.VoidToFutureOfLeaks = dart.constFn(dart_rti.findType("async|Future<leak_tracker__src__shared__shared_model|Leaks>()")))(),
    VoidToFutureOfvoid: () => (T.VoidToFutureOfvoid = dart.constFn(dart_rti.findType("async|Future<~>()")))(),
    BaselinerN: () => (T.BaselinerN = dart.constFn(dart_rti.findType("leak_tracker__src__leak_tracking___baseliner|Baseliner?")))(),
    LeakTrackerN: () => (T.LeakTrackerN = dart.constFn(dart_rti.findType("leak_tracker__src__leak_tracking___leak_tracker|LeakTracker?")))(),
    ObjectRefOfWeakReferenceNOfLeakProvider: () => (T.ObjectRefOfWeakReferenceNOfLeakProvider = dart.constFn(dart_rti.findType("leak_tracker__src__shared___primitives|ObjectRef<core|WeakReference<leak_tracker__src__shared__shared_model|LeakProvider>?>")))(),
    ObjectRefOfPhaseSettings: () => (T.ObjectRefOfPhaseSettings = dart.constFn(dart_rti.findType("leak_tracker__src__shared___primitives|ObjectRef<leak_tracker__src__leak_tracking__primitives__model|PhaseSettings>")))(),
    WeakReferenceNOfLeakProvider: () => (T.WeakReferenceNOfLeakProvider = dart.constFn(dart_rti.findType("core|WeakReference<leak_tracker__src__shared__shared_model|LeakProvider>?")))(),
    String: () => (T.String = dart.constFn(dart_rti.findType("core|String")))(),
    intN: () => (T.intN = dart.constFn(dart_rti.findType("core|int?")))()
  };
  var G = {
    WeakReferenceOfLeakProvider: () => (G.WeakReferenceOfLeakProvider = dart.constFn(core.WeakReference$(T.LeakProvider())))(),
    FutureOfLeakSummary: () => (G.FutureOfLeakSummary = dart.constFn(async.Future$(T.LeakSummary())))(),
    LinkedMapOfLeakType$int: () => (G.LinkedMapOfLeakType$int = dart.constFn(_js_helper.LinkedMap$(T.LeakType(), T.int())))(),
    FutureOfLeaks: () => (G.FutureOfLeaks = dart.constFn(async.Future$(T.Leaks())))(),
    LinkedMapOfLeakType$ListOfLeakReport: () => (G.LinkedMapOfLeakType$ListOfLeakReport = dart.constFn(_js_helper.LinkedMap$(T.LeakType(), T.ListOfLeakReport())))(),
    ObjectRefOfWeakReferenceNOfLeakProvider: () => (G.ObjectRefOfWeakReferenceNOfLeakProvider = dart.constFn(_primitives.ObjectRef$(T.WeakReferenceNOfLeakProvider())))(),
    ObjectRefOfPhaseSettings: () => (G.ObjectRefOfPhaseSettings = dart.constFn(_primitives.ObjectRef$(T.PhaseSettings())))()
  };
  const CT = Object.create({
    _: () => (C, CT)
  });
  dart.defineLazy(CT, {
    get C1() {
      return C[1] = dart.const(Object.setPrototypeOf({
        [Duration__duration]: 100000
      }, core.Duration.prototype));
    },
    get C2() {
      return C[2] = dart.const(Object.setPrototypeOf({
        [Duration__duration]: 1000000
      }, core.Duration.prototype));
    },
    get C0() {
      return C[0] = dart.const(Object.setPrototypeOf({
        [LeakTrackingConfig_maxRequestsForRetainingPath]: 10,
        [LeakTrackingConfig_disposalTime]: C[1] || CT.C1,
        [LeakTrackingConfig_onLeaks]: null,
        [LeakTrackingConfig_notifyDevTools]: true,
        [LeakTrackingConfig_stdoutLeaks]: true,
        [LeakTrackingConfig_checkPeriod]: C[2] || CT.C2,
        [LeakTrackingConfig_numberOfGcCycles]: 3
      }, model.LeakTrackingConfig.prototype));
    },
    get C3() {
      return C[3] = dart.fn(leak_tracking.LeakTracking.dispatchObjectCreated, T.__Tovoid());
    },
    get C4() {
      return C[4] = dart.fn(leak_tracking.LeakTracking.dispatchObjectDisposed, T.__Tovoid$1());
    },
    get C6() {
      return C[6] = dart.const(Object.setPrototypeOf({
        [LeakDiagnosticConfig_collectRetainingPathForNotGCed]: false,
        [LeakDiagnosticConfig_collectStackTraceOnDisposal]: false,
        [LeakDiagnosticConfig_collectStackTraceOnStart]: false
      }, model.LeakDiagnosticConfig.prototype));
    },
    get C9() {
      return C[9] = dart.constMap(T.String(), T.intN(), []);
    },
    get C8() {
      return C[8] = dart.const(Object.setPrototypeOf({
        [IgnoredLeaksSet_ignoreAll]: false,
        [IgnoredLeaksSet_byClass]: C[9] || CT.C9
      }, model.IgnoredLeaksSet.prototype));
    },
    get C7() {
      return C[7] = dart.const(Object.setPrototypeOf({
        [IgnoredLeaks_notDisposed]: C[8] || CT.C8,
        [IgnoredLeaks_notGCed]: C[8] || CT.C8
      }, model.IgnoredLeaks.prototype));
    },
    get C5() {
      return C[5] = dart.const(Object.setPrototypeOf({
        [PhaseSettings_baselining]: null,
        [PhaseSettings_leakDiagnosticConfig]: C[6] || CT.C6,
        [PhaseSettings_ignoredLeaks]: C[7] || CT.C7,
        [PhaseSettings_name]: null,
        [PhaseSettings_ignoreLeaks]: false
      }, model.PhaseSettings.prototype));
    }
  }, false);
  var C = Array(10).fill(void 0);
  var I = [
    "file:///Users/haggaibarel/.pub-cache/hosted/pub.dev/leak_tracker-10.0.0/lib/src/leak_tracking/leak_tracking.dart",
    "package:leak_tracker/src/leak_tracking/leak_tracking.dart",
    "package:leak_tracker/src/leak_tracking/_baseliner.dart",
    "package:leak_tracker/src/leak_tracking/_leak_tracker.dart",
    "package:leak_tracker/src/shared/_primitives.dart",
    "dart:core"
  ];
  var LeakTrackingConfig_maxRequestsForRetainingPath = dart.privateName(model, "LeakTrackingConfig.maxRequestsForRetainingPath");
  var Duration__duration = dart.privateName(core, "Duration._duration");
  var LeakTrackingConfig_disposalTime = dart.privateName(model, "LeakTrackingConfig.disposalTime");
  var LeakTrackingConfig_onLeaks = dart.privateName(model, "LeakTrackingConfig.onLeaks");
  var LeakTrackingConfig_notifyDevTools = dart.privateName(model, "LeakTrackingConfig.notifyDevTools");
  var LeakTrackingConfig_stdoutLeaks = dart.privateName(model, "LeakTrackingConfig.stdoutLeaks");
  var LeakTrackingConfig_checkPeriod = dart.privateName(model, "LeakTrackingConfig.checkPeriod");
  var LeakTrackingConfig_numberOfGcCycles = dart.privateName(model, "LeakTrackingConfig.numberOfGcCycles");
  var PhaseSettings_baselining = dart.privateName(model, "PhaseSettings.baselining");
  var LeakDiagnosticConfig_collectRetainingPathForNotGCed = dart.privateName(model, "LeakDiagnosticConfig.collectRetainingPathForNotGCed");
  var LeakDiagnosticConfig_collectStackTraceOnDisposal = dart.privateName(model, "LeakDiagnosticConfig.collectStackTraceOnDisposal");
  var LeakDiagnosticConfig_collectStackTraceOnStart = dart.privateName(model, "LeakDiagnosticConfig.collectStackTraceOnStart");
  var PhaseSettings_leakDiagnosticConfig = dart.privateName(model, "PhaseSettings.leakDiagnosticConfig");
  var IgnoredLeaksSet_ignoreAll = dart.privateName(model, "IgnoredLeaksSet.ignoreAll");
  var IgnoredLeaksSet_byClass = dart.privateName(model, "IgnoredLeaksSet.byClass");
  var IgnoredLeaks_notDisposed = dart.privateName(model, "IgnoredLeaks.notDisposed");
  var IgnoredLeaks_notGCed = dart.privateName(model, "IgnoredLeaks.notGCed");
  var PhaseSettings_ignoredLeaks = dart.privateName(model, "PhaseSettings.ignoredLeaks");
  var PhaseSettings_name = dart.privateName(model, "PhaseSettings.name");
  var PhaseSettings_ignoreLeaks = dart.privateName(model, "PhaseSettings.ignoreLeaks");
  leak_tracking.LeakTracking = class LeakTracking extends core.Object {
    static get phase() {
      return leak_tracking.LeakTracking._phase.value;
    }
    static set phase(value) {
      if (dart.equals(leak_tracking.LeakTracking._phase.value, value)) return;
      leak_tracking.LeakTracking._baseliner = _baseliner.Baseliner.finishOldAndStartNew(leak_tracking.LeakTracking._baseliner, value.baselining);
      leak_tracking.LeakTracking._phase.value = value;
    }
    static get isStarted() {
      return leak_tracking.LeakTracking._leakTracker != null;
    }
    static start(opts) {
      let config = opts && 'config' in opts ? opts.config : C[0] || CT.C0;
      let resetIfAlreadyStarted = opts && 'resetIfAlreadyStarted' in opts ? opts.resetIfAlreadyStarted : false;
      if (!dart.fn(() => {
        if (leak_tracking.LeakTracking._leakTracker != null) {
          if (!resetIfAlreadyStarted) {
            dart.throw(new core.StateError.new("Leak tracking is already enabled."));
          }
          leak_tracking.LeakTracking.stop();
        }
        let leakTracker = leak_tracking.LeakTracking._leakTracker = new _leak_tracker.LeakTracker.new(config, leak_tracking.LeakTracking._phase);
        leak_tracking.LeakTracking._leakProvider.value = G.WeakReferenceOfLeakProvider().new(leakTracker.objectTracker);
        if (config.notifyDevTools) {
          _registration.initializeDevToolsIntegration(leak_tracking.LeakTracking._leakProvider);
        } else {
          _registration.registerLeakTrackingServiceExtension();
        }
        return true;
      }, T.VoidTobool())()) dart.assertFailed(null, I[0], 61, 12, "() {\n      if (_leakTracker != null) {\n        if (!resetIfAlreadyStarted) {\n          throw StateError('Leak tracking is already enabled.');\n        }\n        stop();\n      }\n\n      final leakTracker = _leakTracker = LeakTracker(config, _phase);\n      _leakProvider.value = WeakReference(leakTracker.objectTracker);\n\n      if (config.notifyDevTools) {\n        // While [leakTracker] will push summary leak notifications to DevTools,\n        // DevTools may request leak details from\n        // the application via integration.\n        // That's why it needs [_leakProvider].\n        initializeDevToolsIntegration(_leakProvider);\n      } else {\n        registerLeakTrackingServiceExtension();\n      }\n      return true;\n    }()");
    }
    static stop() {
      if (!dart.fn(() => {
        let t$360;
        t$360 = leak_tracking.LeakTracking._leakTracker;
        t$360 == null ? null : t$360.dispose();
        leak_tracking.LeakTracking._leakTracker = null;
        _baseliner.Baseliner.finishOldAndStartNew(leak_tracking.LeakTracking._baseliner, null);
        return true;
      }, T.VoidTobool())()) dart.assertFailed(null, I[0], 89, 12, "() {\n      _leakTracker?.dispose();\n      _leakTracker = null;\n      Baseliner.finishOldAndStartNew(_baseliner, null);\n      return true;\n    }()");
    }
    static dispatchObjectEvent(event) {
      if (!dart.fn(() => {
        _dispatcher.dispatchObjectEvent(event, {onStartTracking: C[3] || CT.C3, onDispatchDisposal: C[4] || CT.C4});
        return true;
      }, T.VoidTobool())()) dart.assertFailed(null, I[0], 102, 12, "() {\n      dispatcher.dispatchObjectEvent(\n        event,\n        onStartTracking: dispatchObjectCreated,\n        onDispatchDisposal: dispatchObjectDisposed,\n      );\n      return true;\n    }()");
    }
    static dispatchObjectCreated(opts) {
      let library = opts && 'library' in opts ? opts.library : null;
      let className = opts && 'className' in opts ? opts.className : null;
      let object = opts && 'object' in opts ? opts.object : null;
      let context = opts && 'context' in opts ? opts.context : null;
      if (!dart.fn(() => {
        let t$360, t$360$;
        t$360 = leak_tracking.LeakTracking._baseliner;
        t$360 == null ? null : t$360.takeSample();
        if (leak_tracking.LeakTracking.phase.ignoredLeaks.isIgnored(className)) return true;
        t$360$ = leak_tracking.LeakTracking._leakTracker;
        t$360$ == null ? null : t$360$.objectTracker.startTracking(object, {context: context, trackedClass: _primitives.fullClassName({library: library, shortClassName: className}), phase: leak_tracking.LeakTracking._phase.value});
        return true;
      }, T.VoidTobool())()) dart.assertFailed(null, I[0], 123, 12, "() {\n      _baseliner?.takeSample();\n      if (phase.ignoredLeaks.isIgnored(className)) return true;\n      _leakTracker?.objectTracker.startTracking(\n        object,\n        context: context,\n        trackedClass:\n            fullClassName(library: library, shortClassName: className),\n        phase: _phase.value,\n      );\n\n      return true;\n    }()");
    }
    static dispatchObjectDisposed(opts) {
      let object = opts && 'object' in opts ? opts.object : null;
      let context = opts && 'context' in opts ? opts.context : null;
      if (!dart.fn(() => {
        let t$360, t$360$;
        t$360 = leak_tracking.LeakTracking._baseliner;
        t$360 == null ? null : t$360.takeSample();
        t$360$ = leak_tracking.LeakTracking._leakTracker;
        t$360$ == null ? null : t$360$.objectTracker.dispatchDisposal(object, {context: context});
        return true;
      }, T.VoidTobool())()) dart.assertFailed(null, I[0], 145, 12, "() {\n      _baseliner?.takeSample();\n      _leakTracker?.objectTracker.dispatchDisposal(object, context: context);\n      return true;\n    }()");
    }
    static dispatchObjectTrace(opts) {
      let object = opts && 'object' in opts ? opts.object : null;
      let context = opts && 'context' in opts ? opts.context : null;
      if (!dart.fn(() => {
        let t$360, t$360$;
        t$360 = leak_tracking.LeakTracking._baseliner;
        t$360 == null ? null : t$360.takeSample();
        t$360$ = leak_tracking.LeakTracking._leakTracker;
        t$360$ == null ? null : t$360$.objectTracker.addContext(object, {context: context});
        return true;
      }, T.VoidTobool())()) dart.assertFailed(null, I[0], 159, 12, "() {\n      _baseliner?.takeSample();\n      _leakTracker?.objectTracker.addContext(object, context: context);\n      return true;\n    }()");
    }
    static checkLeaks() {
      return async.async(T.LeakSummary(), function* checkLeaks() {
        let t$360;
        let result = null;
        if (!dart.fn(() => {
          let t$360;
          result = (t$360 = leak_tracking.LeakTracking._leakTracker, t$360 == null ? null : t$360.leakReporter.checkLeaks());
          return true;
        }, T.VoidTobool())()) dart.assertFailed(null, I[0], 170, 12, "() {\n      result = _leakTracker?.leakReporter.checkLeaks();\n      return true;\n    }()");
        return yield (t$360 = result, t$360 == null ? G.FutureOfLeakSummary().value(new shared_model.LeakSummary.new(new (G.LinkedMapOfLeakType$int()).new())) : t$360);
      });
    }
    static collectLeaks() {
      return async.async(T.Leaks(), function* collectLeaks() {
        let t$360;
        let result = null;
        if (!dart.fn(() => {
          let t$360;
          result = (t$360 = leak_tracking.LeakTracking._leakTracker, t$360 == null ? null : t$360.objectTracker.collectLeaks());
          return true;
        }, T.VoidTobool())()) dart.assertFailed(null, I[0], 187, 12, "() {\n      result = _leakTracker?.objectTracker.collectLeaks();\n      return true;\n    }()");
        return yield (t$360 = result, t$360 == null ? G.FutureOfLeaks().value(new shared_model.Leaks.new(new (G.LinkedMapOfLeakType$ListOfLeakReport()).new())) : t$360);
      });
    }
    static checkNotGCed() {
      return async.async(T.void(), function* checkNotGCed() {
        let t$360;
        let result = null;
        if (!dart.fn(() => {
          let t$360;
          result = (t$360 = leak_tracking.LeakTracking._leakTracker, t$360 == null ? null : t$360.objectTracker.checkNotGCed());
          return true;
        }, T.VoidTobool())()) dart.assertFailed(null, I[0], 203, 12, "() {\n      result = _leakTracker?.objectTracker.checkNotGCed();\n      return true;\n    }()");
        yield (t$360 = result, t$360 == null ? async.Future.value() : t$360);
      });
    }
    static declareNotDisposedObjectsAsLeaks() {
      let t$360;
      t$360 = leak_tracking.LeakTracking._leakTracker;
      t$360 == null ? null : t$360.objectTracker.declareAllNotDisposedAsLeaks();
    }
  };
  (leak_tracking.LeakTracking.new = function() {
    ;
  }).prototype = leak_tracking.LeakTracking.prototype;
  dart.addTypeTests(leak_tracking.LeakTracking);
  dart.addRtiResources(leak_tracking.LeakTracking, ["leak_tracker__src__leak_tracking__leak_tracking|LeakTracking"]);
  dart.addTypeCaches(leak_tracking.LeakTracking);
  dart.setStaticMethodSignature(leak_tracking.LeakTracking, () => ['start', 'stop', 'dispatchObjectEvent', 'dispatchObjectCreated', 'dispatchObjectDisposed', 'dispatchObjectTrace', 'checkLeaks', 'collectLeaks', 'checkNotGCed', 'declareNotDisposedObjectsAsLeaks']);
  dart.setStaticGetterSignature(leak_tracking.LeakTracking, () => ['phase', 'isStarted']);
  dart.setStaticSetterSignature(leak_tracking.LeakTracking, () => ['phase']);
  dart.setLibraryUri(leak_tracking.LeakTracking, I[1]);
  dart.setStaticFieldSignature(leak_tracking.LeakTracking, () => ['_baseliner', '_leakTracker', '_leakProvider', 'warnForUnsupportedPlatforms', '_phase']);
  dart.defineLazy(leak_tracking.LeakTracking, {
    /*leak_tracking.LeakTracking._baseliner*/get _baseliner() {
      return null;
    },
    set _baseliner(value) {},
    /*leak_tracking.LeakTracking._leakTracker*/get _leakTracker() {
      return null;
    },
    set _leakTracker(value) {},
    /*leak_tracking.LeakTracking._leakProvider*/get _leakProvider() {
      return new (G.ObjectRefOfWeakReferenceNOfLeakProvider()).new(null);
    },
    /*leak_tracking.LeakTracking.warnForUnsupportedPlatforms*/get warnForUnsupportedPlatforms() {
      return true;
    },
    set warnForUnsupportedPlatforms(value) {},
    /*leak_tracking.LeakTracking._phase*/get _phase() {
      return new (G.ObjectRefOfPhaseSettings()).new(C[5] || CT.C5);
    }
  }, false);
  dart.moduleConstCaches.set("packages/leak_tracker/src/leak_tracking/leak_tracking.dart", C);
  dart_rti._Universe.addRules(dart.typeUniverse, JSON.parse('{"core|String":{"Comparable.T":"core|String","core|Comparable":["core|String"],"core|Pattern":[]},"core|Comparable":{"Comparable.T":"1"},"core|Map":{"Map.K":"1","Map.V":"2"},"leak_tracker__src__shared__shared_model|LeakType":{"core|_Enum":[],"core|Enum":[]},"core|_Enum":{"core|Enum":[]},"core|int":{"core|num":[],"Comparable.T":"core|num","core|Comparable":["core|num"]},"core|num":{"Comparable.T":"core|num","core|Comparable":["core|num"]},"core|List":{"List.E":"1","Iterable.E":"1","core|Iterable":["1"],"_ListIterable.E":"1","core|_ListIterable":["1"],"EfficientLengthIterable.T":"1","_internal|EfficientLengthIterable":["1"],"HideEfficientLengthIterable.T":"1","_internal|HideEfficientLengthIterable":["1"]},"core|Iterable":{"Iterable.E":"1"},"core|_ListIterable":{"_ListIterable.E":"1","EfficientLengthIterable.T":"1","_internal|EfficientLengthIterable":["1"],"HideEfficientLengthIterable.T":"1","_internal|HideEfficientLengthIterable":["1"],"Iterable.E":"1","core|Iterable":["1"]},"_internal|EfficientLengthIterable":{"EfficientLengthIterable.T":"1","Iterable.E":"1","core|Iterable":["1"]},"_internal|HideEfficientLengthIterable":{"HideEfficientLengthIterable.T":"1","Iterable.E":"1","core|Iterable":["1"]},"async|Future":{"Future.T":"1"},"leak_tracker__src__shared___primitives|ObjectRef":{"ObjectRef.T":"1"},"core|WeakReference":{"WeakReference.T":"1"}}'));
  dart.trackLibraries("packages/leak_tracker/src/leak_tracking/leak_tracking.dart", {
    "package:leak_tracker/src/leak_tracking/leak_tracking.dart": leak_tracking
  }, {
  }, '{"version":3,"sourceRoot":"","sources":["leak_tracking.dart"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAkCoC,YAAA,AAAO;IAAK;qBACf;AAC7B,UAAiB,YAAb,AAAO,yCAAS,KAAK,GAAE;AAC3B,8CAAuB,0CAAqB,uCAAY,AAAM,KAAD;AACtD,MAAP,0CAAe,KAAK;IACtB;;AAK6B,YAAA,AAAa;IAAO;;UAa5B;UACd;AAEL,WAAO,AAqBN;AApBC,YAAI;AACF,eAAK,qBAAqB;AACxB,uBAAM,wBAAW;;AAEnB;;AAGI,0BAAc,0CAAe,kCAAY,MAAM,EAAE;AACzC,QAAd,iDAAsB,oCAAc,AAAY,WAAD;AAE/C,YAAI,AAAO,MAAD;AAKR,sDAA8B;;AAE9B;;AAEF,cAAO;;IAEX;;AAME,WAAO,AAKN;;AAJC;+BAAc;AACd,kDAAe;AACL,kDAAqB,uCAAY;AAC3C,cAAO;;IAEX;+BAMiE;AAC/D,WAAO,AAON;AANY,wCACT,KAAK;AAIP,cAAO;;IAEX;;UAQkB;UACA;UACA;UACM;AAEtB,WAAO,AAYN;;AAXC;+BAAY;AACZ,YAAI,AAAM,AAAa,wDAAU,SAAS,GAAG,MAAO;AACpD;gCAAc,AAAc,mCAC1B,MAAM,YACG,OAAO,gBAEZ,oCAAuB,OAAO,kBAAkB,SAAS,WACtD,AAAO;AAGhB,cAAO;;IAEX;;UAMkB;UACM;AAEtB,WAAO,AAIN;;AAHC;+BAAY;AACZ;gCAAc,AAAc,sCAAiB,MAAM,YAAW,OAAO;AACrE,cAAO;;IAEX;;UAMkB;UACM;AAEtB,WAAO,AAIN;;AAHC;+BAAY;AACZ;gCAAc,AAAc,gCAAW,MAAM,YAAW,OAAO;AAC/D,cAAO;;IAEX;;AAGqC;;AACd;AAErB,aAAO,AAGN;;AAFC,qFAAS,OAAc,AAAa;AACpC,gBAAO;;AAGT,cAAO,QAAc,QAAP,MAAM,EAAN,gBAAiB,8BAAM,iCAAY;MACnD;;;AAQiC;;AAChB;AAEf,aAAO,AAGN;;AAFC,qFAAS,OAAc,AAAc;AACrC,gBAAO;;AAGT,cAAO,QAAc,QAAP,MAAM,EAAN,gBAAiB,wBAAM,2BAAM;MAC7C;;;AAOgC;;AAChB;AAEd,aAAO,AAGN;;AAFC,qFAAS,OAAc,AAAc;AACrC,gBAAO;;AAGT,eAAc,QAAP,MAAM,EAAN,gBAAiB;MAC1B;;;;AAOE;6BAAc,AAAc;IAC9B;;;;EACF;;;;;;;;;;MA3MoB,qCAAU;;;;MAER,uCAAY;;;;MAKnB,wCAAa;YAAG,uDAAwC;;MAIzD,sDAA2B;YAAG;;;MAgB7B,iCAAM;YAAG","file":"../../../../../../../../../packages/leak_tracker/src/leak_tracking/leak_tracking.dart.lib.js"}');
  // Exports:
  return {
    src__leak_tracking__leak_tracking: leak_tracking
  };
}));

//# sourceMappingURL=leak_tracking.dart.lib.js.map
