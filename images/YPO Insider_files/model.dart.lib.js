// Generated by DDC, the Dart Development Compiler (to JavaScript).
// Version: 3.3.1 (stable) (Wed Mar 6 13:09:19 2024 +0000) on "macos_arm64"
// Module: packages/leak_tracker/src/leak_tracking/primitives/model.dart
// Flags: newRuntimeTypes(true), soundNullSafety(true), enableAsserts(true)
define(['dart_sdk', 'packages/collection/src/equality.dart', 'packages/leak_tracker/src/shared/shared_model.dart'], (function load__packages__leak_tracker__src__leak_tracking__primitives__model_dart(dart_sdk, packages__collection__src__equality$46dart, packages__leak_tracker__src__shared__shared_model$46dart) {
  'use strict';
  const dart_rti = dart_sdk.dart_rti;
  const core = dart_sdk.core;
  const collection = dart_sdk.collection;
  const math = dart_sdk.math;
  const dart = dart_sdk.dart;
  const dartx = dart_sdk.dartx;
  const equality = packages__collection__src__equality$46dart.src__equality;
  const shared_model = packages__leak_tracker__src__shared__shared_model$46dart.src__shared__shared_model;
  var model = Object.create(dart.library);
  var $keys = dartx.keys;
  var $containsKey = dartx.containsKey;
  var $_get = dartx._get;
  var $_set = dartx._set;
  var $isEmpty = dartx.isEmpty;
  var $remove = dartx.remove;
  var $forEach = dartx.forEach;
  var $runtimeType = dartx.runtimeType;
  var $toDouble = dartx.toDouble;
  var $values = dartx.values;
  dart._checkModuleNullSafetyMode(true);
  dart._checkModuleRuntimeTypes(true);
  var T = {
    String: () => (T.String = dart.constFn(dart_rti.findType("core|String")))(),
    intN: () => (T.intN = dart.constFn(dart_rti.findType("core|int?")))(),
    int: () => (T.int = dart.constFn(dart_rti.findType("core|int")))(),
    IgnoredLeaksSet: () => (T.IgnoredLeaksSet = dart.constFn(dart_rti.findType("leak_tracker__src__leak_tracking__primitives__model|IgnoredLeaksSet")))(),
    Never: () => (T.Never = dart.constFn(dart_rti.findType("0&")))(),
    DefaultEqualityOfNever: () => (T.DefaultEqualityOfNever = dart.constFn(dart_rti.findType("collection__src__equality|DefaultEquality<0&>")))(),
    __ToIgnoredLeaksSet: () => (T.__ToIgnoredLeaksSet = dart.constFn(dart_rti.findType("leak_tracker__src__leak_tracking__primitives__model|IgnoredLeaksSet({byClass:core|Map<core|String,core|int?>?,ignoreAll:core|bool?})")))(),
    IgnoredLeaksSetNToIgnoredLeaksSet: () => (T.IgnoredLeaksSetNToIgnoredLeaksSet = dart.constFn(dart_rti.findType("leak_tracker__src__leak_tracking__primitives__model|IgnoredLeaksSet(leak_tracker__src__leak_tracking__primitives__model|IgnoredLeaksSet?)")))(),
    ListOfStringToIgnoredLeaksSet: () => (T.ListOfStringToIgnoredLeaksSet = dart.constFn(dart_rti.findType("leak_tracker__src__leak_tracking__primitives__model|IgnoredLeaksSet(core|List<core|String>)")))(),
    StringTobool: () => (T.StringTobool = dart.constFn(dart_rti.findType("core|bool(core|String)")))(),
    MapOfString$intN: () => (T.MapOfString$intN = dart.constFn(dart_rti.findType("core|Map<core|String,core|int?>")))(),
    bool: () => (T.bool = dart.constFn(dart_rti.findType("core|bool")))(),
    IgnoredLeaks: () => (T.IgnoredLeaks = dart.constFn(dart_rti.findType("leak_tracker__src__leak_tracking__primitives__model|IgnoredLeaks")))(),
    String__Tobool: () => (T.String__Tobool = dart.constFn(dart_rti.findType("core|bool(core|String{leakType:leak_tracker__src__shared__shared_model|LeakType?})")))(),
    LeakDiagnosticConfig: () => (T.LeakDiagnosticConfig = dart.constFn(dart_rti.findType("leak_tracker__src__leak_tracking__primitives__model|LeakDiagnosticConfig")))(),
    __ToLeakDiagnosticConfig: () => (T.__ToLeakDiagnosticConfig = dart.constFn(dart_rti.findType("leak_tracker__src__leak_tracking__primitives__model|LeakDiagnosticConfig({collectRetainingPathForNotGCed:core|bool?,collectStackTraceOnDisposal:core|bool?,collectStackTraceOnStart:core|bool?})")))(),
    DurationN: () => (T.DurationN = dart.constFn(dart_rti.findType("core|Duration?")))(),
    LeakSummaryToNvoid: () => (T.LeakSummaryToNvoid = dart.constFn(dart_rti.findType("~(leak_tracker__src__shared__shared_model|LeakSummary)?")))(),
    Duration: () => (T.Duration = dart.constFn(dart_rti.findType("core|Duration")))(),
    PhaseSettings: () => (T.PhaseSettings = dart.constFn(dart_rti.findType("leak_tracker__src__leak_tracking__primitives__model|PhaseSettings")))(),
    StringN: () => (T.StringN = dart.constFn(dart_rti.findType("core|String?")))(),
    MemoryBaseliningN: () => (T.MemoryBaseliningN = dart.constFn(dart_rti.findType("leak_tracker__src__leak_tracking__primitives__model|MemoryBaselining?")))(),
    MemoryBaselining: () => (T.MemoryBaselining = dart.constFn(dart_rti.findType("leak_tracker__src__leak_tracking__primitives__model|MemoryBaselining")))(),
    BaseliningMode: () => (T.BaseliningMode = dart.constFn(dart_rti.findType("leak_tracker__src__leak_tracking__primitives__model|BaseliningMode")))(),
    MemoryBaselineN: () => (T.MemoryBaselineN = dart.constFn(dart_rti.findType("leak_tracker__src__leak_tracking__primitives__model|MemoryBaseline?")))(),
    VoidToString: () => (T.VoidToString = dart.constFn(dart_rti.findType("core|String()")))(),
    ListOfBaseliningMode: () => (T.ListOfBaseliningMode = dart.constFn(dart_rti.findType("core|List<leak_tracker__src__leak_tracking__primitives__model|BaseliningMode>")))(),
    MemoryBaseline: () => (T.MemoryBaseline = dart.constFn(dart_rti.findType("leak_tracker__src__leak_tracking__primitives__model|MemoryBaseline")))(),
    ValueSampler: () => (T.ValueSampler = dart.constFn(dart_rti.findType("leak_tracker__src__leak_tracking__primitives__model|ValueSampler")))(),
    double: () => (T.double = dart.constFn(dart_rti.findType("core|double")))(),
    intTovoid: () => (T.intTovoid = dart.constFn(dart_rti.findType("~(core|int)")))(),
    VoidTovoid: () => (T.VoidTovoid = dart.constFn(dart_rti.findType("~()")))()
  };
  var G = {
    LinkedHashMapOfString$intN: () => (G.LinkedHashMapOfString$intN = dart.constFn(collection.LinkedHashMap$(T.String(), T.intN())))(),
    DefaultEqualityOfNever: () => (G.DefaultEqualityOfNever = dart.constFn(equality.DefaultEquality$(T.Never())))()
  };
  const CT = Object.create({
    _: () => (C, CT)
  });
  dart.defineLazy(CT, {
    get C0() {
      return C[0] = dart.constMap(T.String(), T.intN(), []);
    },
    get C2() {
      return C[2] = dart.const(Object.setPrototypeOf({
        $ti: T.DefaultEqualityOfNever()
      }, G.DefaultEqualityOfNever().prototype));
    },
    get C1() {
      return C[1] = dart.const(Object.setPrototypeOf({
        [DeepCollectionEquality__unordered]: true,
        [DeepCollectionEquality__base]: C[2] || CT.C2
      }, equality.DeepCollectionEquality.prototype));
    },
    get C3() {
      return C[3] = dart.const(Object.setPrototypeOf({
        [ignoreAll$]: false,
        [byClass$]: C[0] || CT.C0
      }, model.IgnoredLeaksSet.prototype));
    },
    get C4() {
      return C[4] = dart.const(Object.setPrototypeOf({
        [_Enum__name]: "notDisposed",
        [_Enum_index]: 0
      }, shared_model.LeakType.prototype));
    },
    get C5() {
      return C[5] = dart.const(Object.setPrototypeOf({
        [_Enum__name]: "notGCed",
        [_Enum_index]: 1
      }, shared_model.LeakType.prototype));
    },
    get C6() {
      return C[6] = dart.const(Object.setPrototypeOf({
        [_Enum__name]: "gcedLate",
        [_Enum_index]: 2
      }, shared_model.LeakType.prototype));
    },
    get C7() {
      return C[7] = dart.const(Object.setPrototypeOf({
        [Duration__duration]: 1000000
      }, core.Duration.prototype));
    },
    get C8() {
      return C[8] = dart.const(Object.setPrototypeOf({
        [Duration__duration]: 100000
      }, core.Duration.prototype));
    },
    get C9() {
      return C[9] = dart.const(Object.setPrototypeOf({
        [Duration__duration]: 0
      }, core.Duration.prototype));
    },
    get C10() {
      return C[10] = dart.const(Object.setPrototypeOf({
        [notDisposed$]: C[3] || CT.C3,
        [notGCed$]: C[3] || CT.C3
      }, model.IgnoredLeaks.prototype));
    },
    get C11() {
      return C[11] = dart.const(Object.setPrototypeOf({
        [collectRetainingPathForNotGCed$]: false,
        [collectStackTraceOnDisposal$]: false,
        [collectStackTraceOnStart$]: false
      }, model.LeakDiagnosticConfig.prototype));
    },
    get C12() {
      return C[12] = dart.const(Object.setPrototypeOf({
        [_Enum__name]: "measure",
        [_Enum_index]: 1
      }, model.BaseliningMode.prototype));
    },
    get C14() {
      return C[14] = dart.const(Object.setPrototypeOf({
        [_Enum__name]: "none",
        [_Enum_index]: 0
      }, model.BaseliningMode.prototype));
    },
    get C15() {
      return C[15] = dart.const(Object.setPrototypeOf({
        [_Enum__name]: "regression",
        [_Enum_index]: 2
      }, model.BaseliningMode.prototype));
    },
    get C13() {
      return C[13] = dart.constList([C[14] || CT.C14, C[12] || CT.C12, C[15] || CT.C15], T.BaseliningMode());
    }
  }, false);
  var C = Array(16).fill(void 0);
  var I = [
    "package:leak_tracker/src/leak_tracking/primitives/model.dart",
    "dart:core",
    "file:///Users/haggaibarel/.pub-cache/hosted/pub.dev/leak_tracker-10.0.0/lib/src/leak_tracking/primitives/model.dart"
  ];
  var byClass$ = dart.privateName(model, "IgnoredLeaksSet.byClass");
  var ignoreAll$ = dart.privateName(model, "IgnoredLeaksSet.ignoreAll");
  var _is = dart.privateName(dart_rti, "_is");
  var DeepCollectionEquality__unordered = dart.privateName(equality, "DeepCollectionEquality._unordered");
  var DeepCollectionEquality__base = dart.privateName(equality, "DeepCollectionEquality._base");
  model.IgnoredLeaksSet = class IgnoredLeaksSet extends core.Object {
    get byClass() {
      return this[byClass$];
    }
    set byClass(value) {
      super.byClass = value;
    }
    get ignoreAll() {
      return this[ignoreAll$];
    }
    set ignoreAll(value) {
      super.ignoreAll = value;
    }
    static ['_#new#tearOff'](opts) {
      let byClass = opts && 'byClass' in opts ? opts.byClass : C[0] || CT.C0;
      let ignoreAll = opts && 'ignoreAll' in opts ? opts.ignoreAll : false;
      return new model.IgnoredLeaksSet.new({byClass: byClass, ignoreAll: ignoreAll});
    }
    static ['_#ignore#tearOff']() {
      return new model.IgnoredLeaksSet.ignore();
    }
    static ['_#byClass#tearOff'](byClass) {
      return new model.IgnoredLeaksSet.byClass(byClass);
    }
    copyWith(opts) {
      let t$360, t$360$;
      let byClass = opts && 'byClass' in opts ? opts.byClass : null;
      let ignoreAll = opts && 'ignoreAll' in opts ? opts.ignoreAll : null;
      return new model.IgnoredLeaksSet.new({ignoreAll: (t$360 = ignoreAll, t$360 == null ? this.ignoreAll : t$360), byClass: (t$360$ = byClass, t$360$ == null ? this.byClass : t$360$)});
    }
    merge(other) {
      if (other == null) return this;
      let map = (() => {
        let t$360 = G.LinkedHashMapOfString$intN().of(this.byClass);
        return t$360;
      })();
      for (let theClass of other.byClass[$keys]) {
        if (!map[$containsKey](theClass)) {
          map[$_set](theClass, other.byClass[$_get](theClass));
          continue;
        }
        let otherCount = other.byClass[$_get](theClass);
        let thisCount = this.byClass[$_get](theClass);
        if (thisCount == null || otherCount == null) {
          map[$_set](theClass, null);
          continue;
        }
        map[$_set](theClass, math.max(T.int(), thisCount, otherCount));
      }
      return new model.IgnoredLeaksSet.new({byClass: map, ignoreAll: this.ignoreAll || other.ignoreAll});
    }
    track(list) {
      if (list[$isEmpty]) return this;
      let map = (() => {
        let t$361 = G.LinkedHashMapOfString$intN().of(this.byClass);
        return t$361;
      })();
      list[$forEach](dart.bind(map, $remove));
      return this.copyWith({byClass: map});
    }
    isIgnored(className) {
      if (this.ignoreAll) return true;
      return this.byClass[$containsKey](className) && this.byClass[$_get](className) == null;
    }
    _equals(other) {
      if (other == null) return false;
      if (other === this) {
        return true;
      }
      if (!dart.equals(dart.runtimeType(other), dart.runtimeType(this))) {
        return false;
      }
      return T.IgnoredLeaksSet()[_is](other) && other.ignoreAll === this.ignoreAll && (C[1] || CT.C1).equals(other.byClass, this.byClass);
    }
    get hashCode() {
      return core.Object.hash(this.ignoreAll, model._mapHash(this.byClass));
    }
  };
  (model.IgnoredLeaksSet.new = function(opts) {
    let byClass = opts && 'byClass' in opts ? opts.byClass : C[0] || CT.C0;
    let ignoreAll = opts && 'ignoreAll' in opts ? opts.ignoreAll : false;
    this[byClass$] = byClass;
    this[ignoreAll$] = ignoreAll;
    ;
  }).prototype = model.IgnoredLeaksSet.prototype;
  (model.IgnoredLeaksSet.ignore = function() {
    model.IgnoredLeaksSet.new.call(this, {ignoreAll: true, byClass: C[0] || CT.C0});
  }).prototype = model.IgnoredLeaksSet.prototype;
  (model.IgnoredLeaksSet.byClass = function(byClass) {
    this[byClass$] = byClass;
    this[ignoreAll$] = false;
    ;
  }).prototype = model.IgnoredLeaksSet.prototype;
  dart.addTypeTests(model.IgnoredLeaksSet);
  dart.addRtiResources(model.IgnoredLeaksSet, ["leak_tracker__src__leak_tracking__primitives__model|IgnoredLeaksSet"]);
  dart.addTypeCaches(model.IgnoredLeaksSet);
  dart.setMethodSignature(model.IgnoredLeaksSet, () => dart.global.Object.setPrototypeOf({
    copyWith: T.__ToIgnoredLeaksSet(),
    merge: T.IgnoredLeaksSetNToIgnoredLeaksSet(),
    track: T.ListOfStringToIgnoredLeaksSet(),
    isIgnored: T.StringTobool()
  }, dart.getMethods(dart.global.Object.getPrototypeOf(model.IgnoredLeaksSet))));
  dart.setLibraryUri(model.IgnoredLeaksSet, I[0]);
  dart.setFieldSignature(model.IgnoredLeaksSet, () => dart.global.Object.setPrototypeOf({
    byClass: {type: T.MapOfString$intN(), isConst: false, isFinal: true, libraryUri: I[1]},
    ignoreAll: {type: T.bool(), isConst: false, isFinal: true, libraryUri: I[1]}
  }, dart.getFields(dart.global.Object.getPrototypeOf(model.IgnoredLeaksSet))));
  dart.defineExtensionMethods(model.IgnoredLeaksSet, ['_equals']);
  dart.defineExtensionAccessors(model.IgnoredLeaksSet, ['hashCode']);
  var notGCed$ = dart.privateName(model, "IgnoredLeaks.notGCed");
  var notDisposed$ = dart.privateName(model, "IgnoredLeaks.notDisposed");
  var _Enum__name = dart.privateName(core, "_Enum._name");
  var _Enum_index = dart.privateName(core, "_Enum.index");
  model.IgnoredLeaks = class IgnoredLeaks extends core.Object {
    get notGCed() {
      return this[notGCed$];
    }
    set notGCed(value) {
      super.notGCed = value;
    }
    get notDisposed() {
      return this[notDisposed$];
    }
    set notDisposed(value) {
      super.notDisposed = value;
    }
    static ['_#new#tearOff'](opts) {
      let notGCed = opts && 'notGCed' in opts ? opts.notGCed : C[3] || CT.C3;
      let notDisposed = opts && 'notDisposed' in opts ? opts.notDisposed : C[3] || CT.C3;
      return new model.IgnoredLeaks.new({notGCed: notGCed, notDisposed: notDisposed});
    }
    isIgnored(className, opts) {
      let leakType = opts && 'leakType' in opts ? opts.leakType : null;
      switch (leakType) {
        case void 0:
        case null:
          {
            return this.notGCed.isIgnored(className) && this.notDisposed.isIgnored(className);
          }
        case C[4] || CT.C4:
          {
            return this.notDisposed.isIgnored(className);
          }
        case C[5] || CT.C5:
        case C[6] || CT.C6:
          {
            return this.notGCed.isIgnored(className);
          }
      }
    }
    _equals(other) {
      if (other == null) return false;
      if (other === this) {
        return true;
      }
      if (!dart.equals(dart.runtimeType(other), dart.runtimeType(this))) {
        return false;
      }
      return T.IgnoredLeaks()[_is](other) && dart.equals(other.notGCed, this.notGCed) && dart.equals(other.notDisposed, this.notDisposed);
    }
    get hashCode() {
      return core.Object.hash(this.notGCed, this.notDisposed);
    }
  };
  (model.IgnoredLeaks.new = function(opts) {
    let notGCed = opts && 'notGCed' in opts ? opts.notGCed : C[3] || CT.C3;
    let notDisposed = opts && 'notDisposed' in opts ? opts.notDisposed : C[3] || CT.C3;
    this[notGCed$] = notGCed;
    this[notDisposed$] = notDisposed;
    ;
  }).prototype = model.IgnoredLeaks.prototype;
  dart.addTypeTests(model.IgnoredLeaks);
  dart.addRtiResources(model.IgnoredLeaks, ["leak_tracker__src__leak_tracking__primitives__model|IgnoredLeaks"]);
  dart.addTypeCaches(model.IgnoredLeaks);
  dart.setMethodSignature(model.IgnoredLeaks, () => dart.global.Object.setPrototypeOf({isIgnored: T.String__Tobool()}, dart.getMethods(dart.global.Object.getPrototypeOf(model.IgnoredLeaks))));
  dart.setLibraryUri(model.IgnoredLeaks, I[0]);
  dart.setFieldSignature(model.IgnoredLeaks, () => dart.global.Object.setPrototypeOf({
    notGCed: {type: T.IgnoredLeaksSet(), isConst: false, isFinal: true, libraryUri: I[0]},
    notDisposed: {type: T.IgnoredLeaksSet(), isConst: false, isFinal: true, libraryUri: I[0]}
  }, dart.getFields(dart.global.Object.getPrototypeOf(model.IgnoredLeaks))));
  dart.defineExtensionMethods(model.IgnoredLeaks, ['_equals']);
  dart.defineExtensionAccessors(model.IgnoredLeaks, ['hashCode']);
  var collectStackTraceOnStart$ = dart.privateName(model, "LeakDiagnosticConfig.collectStackTraceOnStart");
  var collectStackTraceOnDisposal$ = dart.privateName(model, "LeakDiagnosticConfig.collectStackTraceOnDisposal");
  var collectRetainingPathForNotGCed$ = dart.privateName(model, "LeakDiagnosticConfig.collectRetainingPathForNotGCed");
  model.LeakDiagnosticConfig = class LeakDiagnosticConfig extends core.Object {
    get collectStackTraceOnStart() {
      return this[collectStackTraceOnStart$];
    }
    set collectStackTraceOnStart(value) {
      super.collectStackTraceOnStart = value;
    }
    get collectStackTraceOnDisposal() {
      return this[collectStackTraceOnDisposal$];
    }
    set collectStackTraceOnDisposal(value) {
      super.collectStackTraceOnDisposal = value;
    }
    get collectRetainingPathForNotGCed() {
      return this[collectRetainingPathForNotGCed$];
    }
    set collectRetainingPathForNotGCed(value) {
      super.collectRetainingPathForNotGCed = value;
    }
    static ['_#new#tearOff'](opts) {
      let collectRetainingPathForNotGCed = opts && 'collectRetainingPathForNotGCed' in opts ? opts.collectRetainingPathForNotGCed : false;
      let collectStackTraceOnStart = opts && 'collectStackTraceOnStart' in opts ? opts.collectStackTraceOnStart : false;
      let collectStackTraceOnDisposal = opts && 'collectStackTraceOnDisposal' in opts ? opts.collectStackTraceOnDisposal : false;
      return new model.LeakDiagnosticConfig.new({collectRetainingPathForNotGCed: collectRetainingPathForNotGCed, collectStackTraceOnStart: collectStackTraceOnStart, collectStackTraceOnDisposal: collectStackTraceOnDisposal});
    }
    copyWith(opts) {
      let t$362, t$362$, t$362$0;
      let collectRetainingPathForNotGCed = opts && 'collectRetainingPathForNotGCed' in opts ? opts.collectRetainingPathForNotGCed : null;
      let collectStackTraceOnStart = opts && 'collectStackTraceOnStart' in opts ? opts.collectStackTraceOnStart : null;
      let collectStackTraceOnDisposal = opts && 'collectStackTraceOnDisposal' in opts ? opts.collectStackTraceOnDisposal : null;
      return new model.LeakDiagnosticConfig.new({collectRetainingPathForNotGCed: (t$362 = collectRetainingPathForNotGCed, t$362 == null ? this.collectRetainingPathForNotGCed : t$362), collectStackTraceOnStart: (t$362$ = collectStackTraceOnStart, t$362$ == null ? this.collectStackTraceOnStart : t$362$), collectStackTraceOnDisposal: (t$362$0 = collectStackTraceOnDisposal, t$362$0 == null ? this.collectStackTraceOnDisposal : t$362$0)});
    }
    _equals(other) {
      if (other == null) return false;
      if (other === this) {
        return true;
      }
      if (!dart.equals(dart.runtimeType(other), dart.runtimeType(this))) {
        return false;
      }
      return T.LeakDiagnosticConfig()[_is](other) && other.collectStackTraceOnStart === this.collectStackTraceOnStart && other.collectStackTraceOnDisposal === this.collectStackTraceOnDisposal && other.collectRetainingPathForNotGCed === this.collectRetainingPathForNotGCed;
    }
    get hashCode() {
      return core.Object.hash(this.collectStackTraceOnStart, this.collectStackTraceOnDisposal, this.collectRetainingPathForNotGCed);
    }
  };
  (model.LeakDiagnosticConfig.new = function(opts) {
    let collectRetainingPathForNotGCed = opts && 'collectRetainingPathForNotGCed' in opts ? opts.collectRetainingPathForNotGCed : false;
    let collectStackTraceOnStart = opts && 'collectStackTraceOnStart' in opts ? opts.collectStackTraceOnStart : false;
    let collectStackTraceOnDisposal = opts && 'collectStackTraceOnDisposal' in opts ? opts.collectStackTraceOnDisposal : false;
    this[collectRetainingPathForNotGCed$] = collectRetainingPathForNotGCed;
    this[collectStackTraceOnStart$] = collectStackTraceOnStart;
    this[collectStackTraceOnDisposal$] = collectStackTraceOnDisposal;
    ;
  }).prototype = model.LeakDiagnosticConfig.prototype;
  dart.addTypeTests(model.LeakDiagnosticConfig);
  dart.addRtiResources(model.LeakDiagnosticConfig, ["leak_tracker__src__leak_tracking__primitives__model|LeakDiagnosticConfig"]);
  dart.addTypeCaches(model.LeakDiagnosticConfig);
  dart.setMethodSignature(model.LeakDiagnosticConfig, () => dart.global.Object.setPrototypeOf({copyWith: T.__ToLeakDiagnosticConfig()}, dart.getMethods(dart.global.Object.getPrototypeOf(model.LeakDiagnosticConfig))));
  dart.setLibraryUri(model.LeakDiagnosticConfig, I[0]);
  dart.setFieldSignature(model.LeakDiagnosticConfig, () => dart.global.Object.setPrototypeOf({
    collectStackTraceOnStart: {type: T.bool(), isConst: false, isFinal: true, libraryUri: I[1]},
    collectStackTraceOnDisposal: {type: T.bool(), isConst: false, isFinal: true, libraryUri: I[1]},
    collectRetainingPathForNotGCed: {type: T.bool(), isConst: false, isFinal: true, libraryUri: I[1]}
  }, dart.getFields(dart.global.Object.getPrototypeOf(model.LeakDiagnosticConfig))));
  dart.defineExtensionMethods(model.LeakDiagnosticConfig, ['_equals']);
  dart.defineExtensionAccessors(model.LeakDiagnosticConfig, ['hashCode']);
  var numberOfGcCycles$ = dart.privateName(model, "LeakTrackingConfig.numberOfGcCycles");
  var checkPeriod$ = dart.privateName(model, "LeakTrackingConfig.checkPeriod");
  var stdoutLeaks$ = dart.privateName(model, "LeakTrackingConfig.stdoutLeaks");
  var notifyDevTools$ = dart.privateName(model, "LeakTrackingConfig.notifyDevTools");
  var onLeaks$ = dart.privateName(model, "LeakTrackingConfig.onLeaks");
  var disposalTime$ = dart.privateName(model, "LeakTrackingConfig.disposalTime");
  var maxRequestsForRetainingPath$ = dart.privateName(model, "LeakTrackingConfig.maxRequestsForRetainingPath");
  var Duration__duration = dart.privateName(core, "Duration._duration");
  model.LeakTrackingConfig = class LeakTrackingConfig extends core.Object {
    get numberOfGcCycles() {
      return this[numberOfGcCycles$];
    }
    set numberOfGcCycles(value) {
      super.numberOfGcCycles = value;
    }
    get checkPeriod() {
      return this[checkPeriod$];
    }
    set checkPeriod(value) {
      super.checkPeriod = value;
    }
    get stdoutLeaks() {
      return this[stdoutLeaks$];
    }
    set stdoutLeaks(value) {
      super.stdoutLeaks = value;
    }
    get notifyDevTools() {
      return this[notifyDevTools$];
    }
    set notifyDevTools(value) {
      super.notifyDevTools = value;
    }
    get onLeaks() {
      return this[onLeaks$];
    }
    set onLeaks(value) {
      super.onLeaks = value;
    }
    get disposalTime() {
      return this[disposalTime$];
    }
    set disposalTime(value) {
      super.disposalTime = value;
    }
    get maxRequestsForRetainingPath() {
      return this[maxRequestsForRetainingPath$];
    }
    set maxRequestsForRetainingPath(value) {
      super.maxRequestsForRetainingPath = value;
    }
    static ['_#new#tearOff'](opts) {
      let stdoutLeaks = opts && 'stdoutLeaks' in opts ? opts.stdoutLeaks : true;
      let notifyDevTools = opts && 'notifyDevTools' in opts ? opts.notifyDevTools : true;
      let onLeaks = opts && 'onLeaks' in opts ? opts.onLeaks : null;
      let checkPeriod = opts && 'checkPeriod' in opts ? opts.checkPeriod : C[7] || CT.C7;
      let disposalTime = opts && 'disposalTime' in opts ? opts.disposalTime : C[8] || CT.C8;
      let numberOfGcCycles = opts && 'numberOfGcCycles' in opts ? opts.numberOfGcCycles : 3;
      let maxRequestsForRetainingPath = opts && 'maxRequestsForRetainingPath' in opts ? opts.maxRequestsForRetainingPath : 10;
      return new model.LeakTrackingConfig.new({stdoutLeaks: stdoutLeaks, notifyDevTools: notifyDevTools, onLeaks: onLeaks, checkPeriod: checkPeriod, disposalTime: disposalTime, numberOfGcCycles: numberOfGcCycles, maxRequestsForRetainingPath: maxRequestsForRetainingPath});
    }
    static ['_#passive#tearOff'](opts) {
      let numberOfGcCycles = opts && 'numberOfGcCycles' in opts ? opts.numberOfGcCycles : 3;
      let disposalTime = opts && 'disposalTime' in opts ? opts.disposalTime : C[9] || CT.C9;
      let maxRequestsForRetainingPath = opts && 'maxRequestsForRetainingPath' in opts ? opts.maxRequestsForRetainingPath : 10;
      return new model.LeakTrackingConfig.passive({numberOfGcCycles: numberOfGcCycles, disposalTime: disposalTime, maxRequestsForRetainingPath: maxRequestsForRetainingPath});
    }
  };
  (model.LeakTrackingConfig.new = function(opts) {
    let stdoutLeaks = opts && 'stdoutLeaks' in opts ? opts.stdoutLeaks : true;
    let notifyDevTools = opts && 'notifyDevTools' in opts ? opts.notifyDevTools : true;
    let onLeaks = opts && 'onLeaks' in opts ? opts.onLeaks : null;
    let checkPeriod = opts && 'checkPeriod' in opts ? opts.checkPeriod : C[7] || CT.C7;
    let disposalTime = opts && 'disposalTime' in opts ? opts.disposalTime : C[8] || CT.C8;
    let numberOfGcCycles = opts && 'numberOfGcCycles' in opts ? opts.numberOfGcCycles : 3;
    let maxRequestsForRetainingPath = opts && 'maxRequestsForRetainingPath' in opts ? opts.maxRequestsForRetainingPath : 10;
    this[stdoutLeaks$] = stdoutLeaks;
    this[notifyDevTools$] = notifyDevTools;
    this[onLeaks$] = onLeaks;
    this[checkPeriod$] = checkPeriod;
    this[disposalTime$] = disposalTime;
    this[numberOfGcCycles$] = numberOfGcCycles;
    this[maxRequestsForRetainingPath$] = maxRequestsForRetainingPath;
    ;
  }).prototype = model.LeakTrackingConfig.prototype;
  (model.LeakTrackingConfig.passive = function(opts) {
    let numberOfGcCycles = opts && 'numberOfGcCycles' in opts ? opts.numberOfGcCycles : 3;
    let disposalTime = opts && 'disposalTime' in opts ? opts.disposalTime : C[9] || CT.C9;
    let maxRequestsForRetainingPath = opts && 'maxRequestsForRetainingPath' in opts ? opts.maxRequestsForRetainingPath : 10;
    model.LeakTrackingConfig.new.call(this, {stdoutLeaks: false, notifyDevTools: false, checkPeriod: null, disposalTime: disposalTime, numberOfGcCycles: numberOfGcCycles, maxRequestsForRetainingPath: maxRequestsForRetainingPath});
  }).prototype = model.LeakTrackingConfig.prototype;
  dart.addTypeTests(model.LeakTrackingConfig);
  dart.addRtiResources(model.LeakTrackingConfig, ["leak_tracker__src__leak_tracking__primitives__model|LeakTrackingConfig"]);
  dart.addTypeCaches(model.LeakTrackingConfig);
  dart.setLibraryUri(model.LeakTrackingConfig, I[0]);
  dart.setFieldSignature(model.LeakTrackingConfig, () => dart.global.Object.setPrototypeOf({
    numberOfGcCycles: {type: T.int(), isConst: false, isFinal: true, libraryUri: I[1]},
    checkPeriod: {type: T.DurationN(), isConst: false, isFinal: true, libraryUri: I[1]},
    stdoutLeaks: {type: T.bool(), isConst: false, isFinal: true, libraryUri: I[1]},
    notifyDevTools: {type: T.bool(), isConst: false, isFinal: true, libraryUri: I[1]},
    onLeaks: {type: T.LeakSummaryToNvoid(), isConst: false, isFinal: true},
    disposalTime: {type: T.Duration(), isConst: false, isFinal: true, libraryUri: I[1]},
    maxRequestsForRetainingPath: {type: T.intN(), isConst: false, isFinal: true, libraryUri: I[1]}
  }, dart.getFields(dart.global.Object.getPrototypeOf(model.LeakTrackingConfig))));
  var ignoreLeaks$ = dart.privateName(model, "PhaseSettings.ignoreLeaks");
  var name$ = dart.privateName(model, "PhaseSettings.name");
  var ignoredLeaks$ = dart.privateName(model, "PhaseSettings.ignoredLeaks");
  var leakDiagnosticConfig$ = dart.privateName(model, "PhaseSettings.leakDiagnosticConfig");
  var baselining$ = dart.privateName(model, "PhaseSettings.baselining");
  model.PhaseSettings = class PhaseSettings extends core.Object {
    get ignoreLeaks() {
      return this[ignoreLeaks$];
    }
    set ignoreLeaks(value) {
      super.ignoreLeaks = value;
    }
    get name() {
      return this[name$];
    }
    set name(value) {
      super.name = value;
    }
    get ignoredLeaks() {
      return this[ignoredLeaks$];
    }
    set ignoredLeaks(value) {
      super.ignoredLeaks = value;
    }
    get leakDiagnosticConfig() {
      return this[leakDiagnosticConfig$];
    }
    set leakDiagnosticConfig(value) {
      super.leakDiagnosticConfig = value;
    }
    get baselining() {
      return this[baselining$];
    }
    set baselining(value) {
      super.baselining = value;
    }
    static ['_#new#tearOff'](opts) {
      let ignoredLeaks = opts && 'ignoredLeaks' in opts ? opts.ignoredLeaks : C[10] || CT.C10;
      let ignoreLeaks = opts && 'ignoreLeaks' in opts ? opts.ignoreLeaks : false;
      let name = opts && 'name' in opts ? opts.name : null;
      let leakDiagnosticConfig = opts && 'leakDiagnosticConfig' in opts ? opts.leakDiagnosticConfig : C[11] || CT.C11;
      let baselining = opts && 'baselining' in opts ? opts.baselining : null;
      return new model.PhaseSettings.new({ignoredLeaks: ignoredLeaks, ignoreLeaks: ignoreLeaks, name: name, leakDiagnosticConfig: leakDiagnosticConfig, baselining: baselining});
    }
    static ['_#ignored#tearOff']() {
      return new model.PhaseSettings.ignored();
    }
    _equals(other) {
      if (other == null) return false;
      if (other === this) {
        return true;
      }
      if (!dart.equals(dart.runtimeType(other), dart.runtimeType(this))) {
        return false;
      }
      return T.PhaseSettings()[_is](other) && other.ignoreLeaks === this.ignoreLeaks && other.name == this.name && dart.equals(other.ignoredLeaks, this.ignoredLeaks) && dart.equals(other.leakDiagnosticConfig, this.leakDiagnosticConfig) && dart.equals(other.baselining, this.baselining);
    }
    get hashCode() {
      return core.Object.hash(this.ignoreLeaks, this.name, this.ignoredLeaks, this.baselining);
    }
  };
  (model.PhaseSettings.new = function(opts) {
    let ignoredLeaks = opts && 'ignoredLeaks' in opts ? opts.ignoredLeaks : C[10] || CT.C10;
    let ignoreLeaks = opts && 'ignoreLeaks' in opts ? opts.ignoreLeaks : false;
    let name = opts && 'name' in opts ? opts.name : null;
    let leakDiagnosticConfig = opts && 'leakDiagnosticConfig' in opts ? opts.leakDiagnosticConfig : C[11] || CT.C11;
    let baselining = opts && 'baselining' in opts ? opts.baselining : null;
    this[ignoredLeaks$] = ignoredLeaks;
    this[ignoreLeaks$] = ignoreLeaks;
    this[name$] = name;
    this[leakDiagnosticConfig$] = leakDiagnosticConfig;
    this[baselining$] = baselining;
    ;
  }).prototype = model.PhaseSettings.prototype;
  (model.PhaseSettings.ignored = function() {
    model.PhaseSettings.new.call(this, {ignoreLeaks: true});
  }).prototype = model.PhaseSettings.prototype;
  dart.addTypeTests(model.PhaseSettings);
  dart.addRtiResources(model.PhaseSettings, ["leak_tracker__src__leak_tracking__primitives__model|PhaseSettings"]);
  dart.addTypeCaches(model.PhaseSettings);
  dart.setLibraryUri(model.PhaseSettings, I[0]);
  dart.setFieldSignature(model.PhaseSettings, () => dart.global.Object.setPrototypeOf({
    ignoreLeaks: {type: T.bool(), isConst: false, isFinal: true, libraryUri: I[1]},
    name: {type: T.StringN(), isConst: false, isFinal: true, libraryUri: I[1]},
    ignoredLeaks: {type: T.IgnoredLeaks(), isConst: false, isFinal: true, libraryUri: I[0]},
    leakDiagnosticConfig: {type: T.LeakDiagnosticConfig(), isConst: false, isFinal: true, libraryUri: I[0]},
    baselining: {type: T.MemoryBaseliningN(), isConst: false, isFinal: true, libraryUri: I[0]}
  }, dart.getFields(dart.global.Object.getPrototypeOf(model.PhaseSettings))));
  dart.defineExtensionMethods(model.PhaseSettings, ['_equals']);
  dart.defineExtensionAccessors(model.PhaseSettings, ['hashCode']);
  var mode$ = dart.privateName(model, "MemoryBaselining.mode");
  var baseline$ = dart.privateName(model, "MemoryBaselining.baseline");
  model.MemoryBaselining = class MemoryBaselining extends core.Object {
    get mode() {
      return this[mode$];
    }
    set mode(value) {
      super.mode = value;
    }
    get baseline() {
      return this[baseline$];
    }
    set baseline(value) {
      super.baseline = value;
    }
    static ['_#new#tearOff'](opts) {
      let mode = opts && 'mode' in opts ? opts.mode : C[12] || CT.C12;
      let baseline = opts && 'baseline' in opts ? opts.baseline : null;
      return new model.MemoryBaselining.new({mode: mode, baseline: baseline});
    }
    static ['_#none#tearOff']() {
      return new model.MemoryBaselining.none();
    }
    _equals(other) {
      if (other == null) return false;
      if (!dart.equals(dart.runtimeType(other), dart.runtimeType(this))) {
        return false;
      }
      return T.MemoryBaselining()[_is](other) && other.mode === this.mode && dart.equals(other.baseline, this.baseline);
    }
    get hashCode() {
      return core.Object.hash(this.mode, this.baseline);
    }
  };
  (model.MemoryBaselining.new = function(opts) {
    let mode = opts && 'mode' in opts ? opts.mode : C[12] || CT.C12;
    let baseline = opts && 'baseline' in opts ? opts.baseline : null;
    this[mode$] = mode;
    this[baseline$] = baseline;
    if (!!(mode === model.BaseliningMode.regression && baseline == null)) dart.assertFailed(null, I[2], 379, 15, "!(mode == BaseliningMode.regression && baseline == null)");
    ;
  }).prototype = model.MemoryBaselining.prototype;
  (model.MemoryBaselining.none = function() {
    this[mode$] = model.BaseliningMode.none;
    this[baseline$] = null;
    ;
  }).prototype = model.MemoryBaselining.prototype;
  dart.addTypeTests(model.MemoryBaselining);
  dart.addRtiResources(model.MemoryBaselining, ["leak_tracker__src__leak_tracking__primitives__model|MemoryBaselining"]);
  dart.addTypeCaches(model.MemoryBaselining);
  dart.setLibraryUri(model.MemoryBaselining, I[0]);
  dart.setFieldSignature(model.MemoryBaselining, () => dart.global.Object.setPrototypeOf({
    mode: {type: T.BaseliningMode(), isConst: false, isFinal: true, libraryUri: I[0]},
    baseline: {type: T.MemoryBaselineN(), isConst: false, isFinal: true, libraryUri: I[0]}
  }, dart.getFields(dart.global.Object.getPrototypeOf(model.MemoryBaselining))));
  dart.defineExtensionMethods(model.MemoryBaselining, ['_equals']);
  dart.defineExtensionAccessors(model.MemoryBaselining, ['hashCode']);
  var _name = dart.privateName(core, "_name");
  var _enumToString = dart.privateName(core, "_enumToString");
  model.BaseliningMode = class BaseliningMode extends core._Enum {
    [_enumToString]() {
      return "BaseliningMode." + this[_name];
    }
  };
  (model.BaseliningMode.new = function(t$36$35index, t$36$35name) {
    dart.global.Object.getPrototypeOf(model.BaseliningMode).new.call(this, t$36$35index, t$36$35name);
    ;
  }).prototype = model.BaseliningMode.prototype;
  dart.addTypeTests(model.BaseliningMode);
  dart.addRtiResources(model.BaseliningMode, ["leak_tracker__src__leak_tracking__primitives__model|BaseliningMode"]);
  dart.addTypeCaches(model.BaseliningMode);
  dart.setMethodSignature(model.BaseliningMode, () => dart.global.Object.setPrototypeOf({[_enumToString]: T.VoidToString()}, dart.getMethods(dart.global.Object.getPrototypeOf(model.BaseliningMode))));
  dart.setLibraryUri(model.BaseliningMode, I[0]);
  dart.setStaticFieldSignature(model.BaseliningMode, () => ['values', 'none', 'measure', 'regression']);
  dart.defineLazy(model.BaseliningMode, {
    /*model.BaseliningMode.values*/get values() {
      return C[13] || CT.C13;
    },
    /*model.BaseliningMode.none*/get none() {
      return C[14] || CT.C14;
    },
    /*model.BaseliningMode.measure*/get measure() {
      return C[12] || CT.C12;
    },
    /*model.BaseliningMode.regression*/get regression() {
      return C[15] || CT.C15;
    }
  }, false);
  var rss$ = dart.privateName(model, "MemoryBaseline.rss");
  var allowedRssIncrease$ = dart.privateName(model, "MemoryBaseline.allowedRssIncrease");
  model.MemoryBaseline = class MemoryBaseline extends core.Object {
    get rss() {
      return this[rss$];
    }
    set rss(value) {
      super.rss = value;
    }
    get allowedRssIncrease() {
      return this[allowedRssIncrease$];
    }
    set allowedRssIncrease(value) {
      super.allowedRssIncrease = value;
    }
    static ['_#new#tearOff'](opts) {
      let allowedRssIncrease = opts && 'allowedRssIncrease' in opts ? opts.allowedRssIncrease : 1.3;
      let rss = opts && 'rss' in opts ? opts.rss : null;
      return new model.MemoryBaseline.new({allowedRssIncrease: allowedRssIncrease, rss: rss});
    }
    _equals(other) {
      if (other == null) return false;
      if (!dart.equals(dart.runtimeType(other), dart.runtimeType(this))) {
        return false;
      }
      return T.MemoryBaseline()[_is](other) && other.allowedRssIncrease === this.allowedRssIncrease && dart.equals(other.rss, this.rss);
    }
    get hashCode() {
      return core.Object.hash(this.allowedRssIncrease, this.rss);
    }
  };
  (model.MemoryBaseline.new = function(opts) {
    let allowedRssIncrease = opts && 'allowedRssIncrease' in opts ? opts.allowedRssIncrease : 1.3;
    let rss = opts && 'rss' in opts ? opts.rss : null;
    this[allowedRssIncrease$] = allowedRssIncrease;
    this[rss$] = rss;
    ;
  }).prototype = model.MemoryBaseline.prototype;
  dart.addTypeTests(model.MemoryBaseline);
  dart.addRtiResources(model.MemoryBaseline, ["leak_tracker__src__leak_tracking__primitives__model|MemoryBaseline"]);
  dart.addTypeCaches(model.MemoryBaseline);
  dart.setLibraryUri(model.MemoryBaseline, I[0]);
  dart.setFieldSignature(model.MemoryBaseline, () => dart.global.Object.setPrototypeOf({
    rss: {type: T.ValueSampler(), isConst: false, isFinal: true, libraryUri: I[0]},
    allowedRssIncrease: {type: T.double(), isConst: false, isFinal: true, libraryUri: I[1]}
  }, dart.getFields(dart.global.Object.getPrototypeOf(model.MemoryBaseline))));
  dart.defineExtensionMethods(model.MemoryBaseline, ['_equals']);
  dart.defineExtensionAccessors(model.MemoryBaseline, ['hashCode']);
  var initialValue$ = dart.privateName(model, "ValueSampler.initialValue");
  var deltaMax$ = dart.privateName(model, "ValueSampler.deltaMax");
  var absMax$ = dart.privateName(model, "ValueSampler.absMax");
  var samples$ = dart.privateName(model, "ValueSampler.samples");
  var _sealed = dart.privateName(model, "_sealed");
  var _absSum = dart.privateName(model, "_absSum");
  var _deltaSum = dart.privateName(model, "_deltaSum");
  model.ValueSampler = class ValueSampler extends core.Object {
    get initialValue() {
      return this[initialValue$];
    }
    set initialValue(value) {
      super.initialValue = value;
    }
    get deltaMax() {
      return this[deltaMax$];
    }
    set deltaMax(value) {
      this[deltaMax$] = value;
    }
    get absMax() {
      return this[absMax$];
    }
    set absMax(value) {
      this[absMax$] = value;
    }
    get samples() {
      return this[samples$];
    }
    set samples(value) {
      this[samples$] = value;
    }
    static ['_#new#tearOff'](opts) {
      let initialValue = opts && 'initialValue' in opts ? opts.initialValue : null;
      let samples = opts && 'samples' in opts ? opts.samples : null;
      let deltaAvg = opts && 'deltaAvg' in opts ? opts.deltaAvg : null;
      let deltaMax = opts && 'deltaMax' in opts ? opts.deltaMax : null;
      let absAvg = opts && 'absAvg' in opts ? opts.absAvg : null;
      let absMax = opts && 'absMax' in opts ? opts.absMax : null;
      return new model.ValueSampler.new({initialValue: initialValue, samples: samples, deltaAvg: deltaAvg, deltaMax: deltaMax, absAvg: absAvg, absMax: absMax});
    }
    static ['_#start#tearOff'](opts) {
      let initialValue = opts && 'initialValue' in opts ? opts.initialValue : null;
      return new model.ValueSampler.start({initialValue: initialValue});
    }
    get deltaAvg() {
      return this[_deltaSum] / this.samples;
    }
    get absAvg() {
      return this[_absSum] / this.samples;
    }
    add(value) {
      if (this[_sealed]) {
        dart.throw(new core.StateError.new("Cannot add value to sealed sampler."));
      }
      this.absMax = math.max(T.int(), this.absMax, value);
      let delta = value - this.initialValue;
      this.deltaMax = math.max(T.int(), this.deltaMax, delta);
      this[_deltaSum] = this[_deltaSum] + delta;
      this[_absSum] = this[_absSum] + value;
      this.samples = this.samples + 1;
    }
    seal() {
      this[_sealed] = true;
    }
    asDartCode() {
      return "ValueSampler(" + "initialValue: " + dart.strSafe(this.initialValue) + ", " + "deltaAvg: " + dart.strSafe(this.deltaAvg) + ", " + "deltaMax: " + dart.strSafe(this.deltaMax) + ", " + "absAvg: " + dart.strSafe(this.absAvg) + ", " + "absMax: " + dart.strSafe(this.absMax) + ", " + "samples: " + dart.strSafe(this.samples) + ",)";
    }
    _equals(other) {
      if (other == null) return false;
      if (!dart.equals(dart.runtimeType(other), dart.runtimeType(this))) {
        return false;
      }
      return T.ValueSampler()[_is](other) && other.initialValue === this.initialValue && other.deltaAvg === this.deltaAvg && other.deltaMax === this.deltaMax && other.absAvg === this.absAvg && other.absMax === this.absMax && other.samples === this.samples && other[_sealed] === this[_sealed];
    }
    get hashCode() {
      return core.Object.hash(this.initialValue, this.deltaAvg, this.deltaMax, this.absAvg, this.absMax, this.samples, this[_sealed]);
    }
  };
  (model.ValueSampler.new = function(opts) {
    let initialValue = opts && 'initialValue' in opts ? opts.initialValue : null;
    let samples = opts && 'samples' in opts ? opts.samples : null;
    let deltaAvg = opts && 'deltaAvg' in opts ? opts.deltaAvg : null;
    let deltaMax = opts && 'deltaMax' in opts ? opts.deltaMax : null;
    let absAvg = opts && 'absAvg' in opts ? opts.absAvg : null;
    let absMax = opts && 'absMax' in opts ? opts.absMax : null;
    this[_sealed] = false;
    this[initialValue$] = initialValue;
    this[samples$] = samples;
    this[deltaMax$] = deltaMax;
    this[absMax$] = absMax;
    this[_sealed] = true;
    this[_absSum] = absAvg * samples;
    this[_deltaSum] = deltaAvg * samples;
    ;
  }).prototype = model.ValueSampler.prototype;
  (model.ValueSampler.start = function(opts) {
    let initialValue = opts && 'initialValue' in opts ? opts.initialValue : null;
    this[_sealed] = false;
    this[initialValue$] = initialValue;
    this[samples$] = 1;
    this[_deltaSum] = 0.0;
    this[deltaMax$] = 0;
    this[_absSum] = initialValue[$toDouble]();
    this[absMax$] = initialValue;
    ;
  }).prototype = model.ValueSampler.prototype;
  dart.addTypeTests(model.ValueSampler);
  dart.addRtiResources(model.ValueSampler, ["leak_tracker__src__leak_tracking__primitives__model|ValueSampler"]);
  dart.addTypeCaches(model.ValueSampler);
  dart.setMethodSignature(model.ValueSampler, () => dart.global.Object.setPrototypeOf({
    add: T.intTovoid(),
    seal: T.VoidTovoid(),
    asDartCode: T.VoidToString()
  }, dart.getMethods(dart.global.Object.getPrototypeOf(model.ValueSampler))));
  dart.setGetterSignature(model.ValueSampler, () => dart.global.Object.setPrototypeOf({
    deltaAvg: T.double(),
    absAvg: T.double()
  }, dart.getGetters(dart.global.Object.getPrototypeOf(model.ValueSampler))));
  dart.setLibraryUri(model.ValueSampler, I[0]);
  dart.setFieldSignature(model.ValueSampler, () => dart.global.Object.setPrototypeOf({
    initialValue: {type: T.int(), isConst: false, isFinal: true, libraryUri: I[1]},
    [_deltaSum]: {type: T.double(), isConst: false, isFinal: false, libraryUri: I[1]},
    [_absSum]: {type: T.double(), isConst: false, isFinal: false, libraryUri: I[1]},
    deltaMax: {type: T.int(), isConst: false, isFinal: false, libraryUri: I[1]},
    absMax: {type: T.int(), isConst: false, isFinal: false, libraryUri: I[1]},
    samples: {type: T.int(), isConst: false, isFinal: false, libraryUri: I[1]},
    [_sealed]: {type: T.bool(), isConst: false, isFinal: false, libraryUri: I[1]}
  }, dart.getFields(dart.global.Object.getPrototypeOf(model.ValueSampler))));
  dart.defineExtensionMethods(model.ValueSampler, ['_equals']);
  dart.defineExtensionAccessors(model.ValueSampler, ['hashCode']);
  model._mapHash = function _mapHash(map) {
    return core.Object.hash(core.Object.hashAll(map[$keys]), core.Object.hashAll(map[$values]));
  };
  dart.defineLazy(model, {
    /*model.defaultNumberOfGcCycles*/get defaultNumberOfGcCycles() {
      return 3;
    },
    /*model.defaultAllowedRssDeviation*/get defaultAllowedRssDeviation() {
      return 1.3;
    }
  }, false);
  dart.moduleConstCaches.set("packages/leak_tracker/src/leak_tracking/primitives/model.dart", C);
  dart_rti._Universe.addRules(dart.typeUniverse, JSON.parse('{"core|String":{"Comparable.T":"core|String","core|Comparable":["core|String"],"core|Pattern":[]},"core|Comparable":{"Comparable.T":"1"},"core|int":{"core|num":[],"Comparable.T":"core|num","core|Comparable":["core|num"]},"core|num":{"Comparable.T":"core|num","core|Comparable":["core|num"]},"collection__src__equality|DefaultEquality":{"DefaultEquality.E":"1","Equality.E":"1","collection__src__equality|Equality":["1"]},"collection__src__equality|Equality":{"Equality.E":"1"},"core|Map":{"Map.K":"1","Map.V":"2"},"core|List":{"List.E":"1","Iterable.E":"1","core|Iterable":["1"],"_ListIterable.E":"1","core|_ListIterable":["1"],"EfficientLengthIterable.T":"1","_internal|EfficientLengthIterable":["1"],"HideEfficientLengthIterable.T":"1","_internal|HideEfficientLengthIterable":["1"]},"core|Iterable":{"Iterable.E":"1"},"core|_ListIterable":{"_ListIterable.E":"1","EfficientLengthIterable.T":"1","_internal|EfficientLengthIterable":["1"],"HideEfficientLengthIterable.T":"1","_internal|HideEfficientLengthIterable":["1"],"Iterable.E":"1","core|Iterable":["1"]},"_internal|EfficientLengthIterable":{"EfficientLengthIterable.T":"1","Iterable.E":"1","core|Iterable":["1"]},"_internal|HideEfficientLengthIterable":{"HideEfficientLengthIterable.T":"1","Iterable.E":"1","core|Iterable":["1"]},"leak_tracker__src__shared__shared_model|LeakType":{"core|_Enum":[],"core|Enum":[]},"core|_Enum":{"core|Enum":[]},"core|Duration":{"Comparable.T":"core|Duration","core|Comparable":["core|Duration"]},"leak_tracker__src__leak_tracking__primitives__model|BaseliningMode":{"core|_Enum":[],"core|Enum":[]},"core|double":{"core|num":[],"Comparable.T":"core|num","core|Comparable":["core|num"]}}'));
  dart.trackLibraries("packages/leak_tracker/src/leak_tracking/primitives/model.dart", {
    "package:leak_tracker/src/leak_tracking/primitives/model.dart": model
  }, {
  }, '{"version":3,"sourceRoot":"","sources":["model.dart"],"names":[],"mappings":"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","file":"../../../../../../../../../../packages/leak_tracker/src/leak_tracking/primitives/model.dart.lib.js"}');
  // Exports:
  return {
    src__leak_tracking__primitives__model: model
  };
}));

//# sourceMappingURL=model.dart.lib.js.map
