// Generated by DDC, the Dart Development Compiler (to JavaScript).
// Version: 3.3.1 (stable) (Wed Mar 6 13:09:19 2024 +0000) on "macos_arm64"
// Module: packages/leak_tracker_testing/src/leak_testing.dart
// Flags: newRuntimeTypes(true), soundNullSafety(true), enableAsserts(true)
define(['dart_sdk', 'packages/leak_tracker/src/leak_tracking/primitives/model.dart', 'packages/matcher/src/expect/prints_matcher.dart', 'packages/leak_tracker_testing/src/matchers.dart'], (function load__packages__leak_tracker_testing__src__leak_testing_dart(dart_sdk, packages__leak_tracker__src__leak_tracking__primitives__model$46dart, packages__matcher__src__expect__prints_matcher$46dart, packages__leak_tracker_testing__src__matchers$46dart) {
  'use strict';
  const dart_rti = dart_sdk.dart_rti;
  const core = dart_sdk.core;
  const collection = dart_sdk.collection;
  const dart = dart_sdk.dart;
  const dartx = dart_sdk.dartx;
  const model = packages__leak_tracker__src__leak_tracking__primitives__model$46dart.src__leak_tracking__primitives__model;
  const expect = packages__matcher__src__expect__prints_matcher$46dart.src__expect__expect;
  const matchers = packages__leak_tracker_testing__src__matchers$46dart.src__matchers;
  var leak_testing = Object.create(dart.library);
  var $_set = dartx._set;
  var $addAll = dartx.addAll;
  var $runtimeType = dartx.runtimeType;
  dart._checkModuleNullSafetyMode(true);
  dart._checkModuleRuntimeTypes(true);
  var T = {
    String: () => (T.String = dart.constFn(dart_rti.findType("core|String")))(),
    intN: () => (T.intN = dart.constFn(dart_rti.findType("core|int?")))(),
    MapOfString$intNAndListOfStringToMapOfString$intN: () => (T.MapOfString$intNAndListOfStringToMapOfString$intN = dart.constFn(dart_rti.findType("core|Map<core|String,core|int?>(core|Map<core|String,core|int?>,core|List<core|String>)")))(),
    LeakTesting: () => (T.LeakTesting = dart.constFn(dart_rti.findType("leak_tracker_testing__src__leak_testing|LeakTesting")))(),
    bool: () => (T.bool = dart.constFn(dart_rti.findType("core|bool")))(),
    VoidTovoid: () => (T.VoidTovoid = dart.constFn(dart_rti.findType("~()")))(),
    VoidToLeakTesting: () => (T.VoidToLeakTesting = dart.constFn(dart_rti.findType("leak_tracker_testing__src__leak_testing|LeakTesting()")))(),
    __ToLeakTesting: () => (T.__ToLeakTesting = dart.constFn(dart_rti.findType("leak_tracker_testing__src__leak_testing|LeakTesting({allNotDisposed:core|bool,allNotGCed:core|bool,classes:core|List<core|String>,notDisposed:core|Map<core|String,core|int?>,notGCed:core|Map<core|String,core|int?>})")))(),
    __ToLeakTesting$1: () => (T.__ToLeakTesting$1 = dart.constFn(dart_rti.findType("leak_tracker_testing__src__leak_testing|LeakTesting({allNotDisposed:core|bool,allNotGCed:core|bool,classes:core|List<core|String>,notDisposed:core|List<core|String>,notGCed:core|List<core|String>})")))(),
    __ToLeakTesting$2: () => (T.__ToLeakTesting$2 = dart.constFn(dart_rti.findType("leak_tracker_testing__src__leak_testing|LeakTesting({baselining:leak_tracker__src__leak_tracking__primitives__model|MemoryBaselining?,ignore:core|bool?,ignoredLeaks:leak_tracker__src__leak_tracking__primitives__model|IgnoredLeaks?,leakDiagnosticConfig:leak_tracker__src__leak_tracking__primitives__model|LeakDiagnosticConfig?})")))(),
    LeaksTovoid: () => (T.LeaksTovoid = dart.constFn(dart_rti.findType("~(leak_tracker__src__shared__shared_model|Leaks)")))(),
    IgnoredLeaks: () => (T.IgnoredLeaks = dart.constFn(dart_rti.findType("leak_tracker__src__leak_tracking__primitives__model|IgnoredLeaks")))(),
    LeakDiagnosticConfig: () => (T.LeakDiagnosticConfig = dart.constFn(dart_rti.findType("leak_tracker__src__leak_tracking__primitives__model|LeakDiagnosticConfig")))(),
    MemoryBaselining: () => (T.MemoryBaselining = dart.constFn(dart_rti.findType("leak_tracker__src__leak_tracking__primitives__model|MemoryBaselining")))()
  };
  var G = {
    LinkedHashMapOfString$intN: () => (G.LinkedHashMapOfString$intN = dart.constFn(collection.LinkedHashMap$(T.String(), T.intN())))(),
    ListOfString: () => (G.ListOfString = dart.constFn(core.List$(T.String())))()
  };
  const CT = Object.create({
    _: () => (C, CT)
  });
  dart.defineLazy(CT, {
    get C2() {
      return C[2] = dart.constMap(T.String(), T.intN(), []);
    },
    get C1() {
      return C[1] = dart.const(Object.setPrototypeOf({
        [IgnoredLeaksSet_ignoreAll]: false,
        [IgnoredLeaksSet_byClass]: C[2] || CT.C2
      }, model.IgnoredLeaksSet.prototype));
    },
    get C0() {
      return C[0] = dart.const(Object.setPrototypeOf({
        [IgnoredLeaks_notDisposed]: C[1] || CT.C1,
        [IgnoredLeaks_notGCed]: C[1] || CT.C1
      }, model.IgnoredLeaks.prototype));
    },
    get C3() {
      return C[3] = dart.const(Object.setPrototypeOf({
        [LeakDiagnosticConfig_collectRetainingPathForNotGCed]: false,
        [LeakDiagnosticConfig_collectStackTraceOnDisposal]: false,
        [LeakDiagnosticConfig_collectStackTraceOnStart]: false
      }, model.LeakDiagnosticConfig.prototype));
    },
    get C5() {
      return C[5] = dart.const(Object.setPrototypeOf({
        [_Enum__name]: "none",
        [_Enum_index]: 0
      }, model.BaseliningMode.prototype));
    },
    get C4() {
      return C[4] = dart.const(Object.setPrototypeOf({
        [MemoryBaselining_baseline]: null,
        [MemoryBaselining_mode]: C[5] || CT.C5
      }, model.MemoryBaselining.prototype));
    },
    get C6() {
      return C[6] = dart.constList([], T.String());
    },
    get C7() {
      return C[7] = dart.const(Object.setPrototypeOf({
        [baselining$]: C[4] || CT.C4,
        [leakDiagnosticConfig$]: C[3] || CT.C3,
        [ignoredLeaks$]: C[0] || CT.C0,
        [ignore$]: true
      }, leak_testing.LeakTesting.prototype));
    }
  }, false);
  var C = Array(8).fill(void 0);
  var I = [
    "package:leak_tracker_testing/src/leak_testing.dart",
    "dart:core",
    "package:leak_tracker/src/leak_tracking/primitives/model.dart"
  ];
  var ignore$ = dart.privateName(leak_testing, "LeakTesting.ignore");
  var ignoredLeaks$ = dart.privateName(leak_testing, "LeakTesting.ignoredLeaks");
  var leakDiagnosticConfig$ = dart.privateName(leak_testing, "LeakTesting.leakDiagnosticConfig");
  var baselining$ = dart.privateName(leak_testing, "LeakTesting.baselining");
  var IgnoredLeaksSet_ignoreAll = dart.privateName(model, "IgnoredLeaksSet.ignoreAll");
  var IgnoredLeaksSet_byClass = dart.privateName(model, "IgnoredLeaksSet.byClass");
  var IgnoredLeaks_notDisposed = dart.privateName(model, "IgnoredLeaks.notDisposed");
  var IgnoredLeaks_notGCed = dart.privateName(model, "IgnoredLeaks.notGCed");
  var LeakDiagnosticConfig_collectRetainingPathForNotGCed = dart.privateName(model, "LeakDiagnosticConfig.collectRetainingPathForNotGCed");
  var LeakDiagnosticConfig_collectStackTraceOnDisposal = dart.privateName(model, "LeakDiagnosticConfig.collectStackTraceOnDisposal");
  var LeakDiagnosticConfig_collectStackTraceOnStart = dart.privateName(model, "LeakDiagnosticConfig.collectStackTraceOnStart");
  var MemoryBaselining_baseline = dart.privateName(model, "MemoryBaselining.baseline");
  var _Enum__name = dart.privateName(core, "_Enum._name");
  var _Enum_index = dart.privateName(core, "_Enum.index");
  var MemoryBaselining_mode = dart.privateName(model, "MemoryBaselining.mode");
  var _is = dart.privateName(dart_rti, "_is");
  leak_testing.LeakTesting = class LeakTesting extends core.Object {
    get ignore() {
      return this[ignore$];
    }
    set ignore(value) {
      super.ignore = value;
    }
    get ignoredLeaks() {
      return this[ignoredLeaks$];
    }
    set ignoredLeaks(value) {
      super.ignoredLeaks = value;
    }
    get leakDiagnosticConfig() {
      return this[leakDiagnosticConfig$];
    }
    set leakDiagnosticConfig(value) {
      super.leakDiagnosticConfig = value;
    }
    get baselining() {
      return this[baselining$];
    }
    set baselining(value) {
      super.baselining = value;
    }
    static ['_#_#tearOff'](opts) {
      let ignore = opts && 'ignore' in opts ? opts.ignore : true;
      let ignoredLeaks = opts && 'ignoredLeaks' in opts ? opts.ignoredLeaks : C[0] || CT.C0;
      let leakDiagnosticConfig = opts && 'leakDiagnosticConfig' in opts ? opts.leakDiagnosticConfig : C[3] || CT.C3;
      let baselining = opts && 'baselining' in opts ? opts.baselining : C[4] || CT.C4;
      return new leak_testing.LeakTesting.__({ignore: ignore, ignoredLeaks: ignoredLeaks, leakDiagnosticConfig: leakDiagnosticConfig, baselining: baselining});
    }
    static get enabled() {
      return leak_testing.LeakTesting._enabled;
    }
    static enable() {
      return leak_testing.LeakTesting._enabled = true;
    }
    withIgnoredAll() {
      return this.copyWith({ignore: true});
    }
    withTrackedAll() {
      return this.copyWith({ignore: false});
    }
    withCreationStackTrace() {
      return this.copyWith({leakDiagnosticConfig: this.leakDiagnosticConfig.copyWith({collectStackTraceOnStart: true})});
    }
    withDisposalStackTrace() {
      return this.copyWith({leakDiagnosticConfig: this.leakDiagnosticConfig.copyWith({collectStackTraceOnDisposal: true})});
    }
    withRetainingPath() {
      return this.copyWith({leakDiagnosticConfig: this.leakDiagnosticConfig.copyWith({collectRetainingPathForNotGCed: true})});
    }
    withIgnored(opts) {
      let notGCed = opts && 'notGCed' in opts ? opts.notGCed : C[2] || CT.C2;
      let allNotGCed = opts && 'allNotGCed' in opts ? opts.allNotGCed : false;
      let notDisposed = opts && 'notDisposed' in opts ? opts.notDisposed : C[2] || CT.C2;
      let allNotDisposed = opts && 'allNotDisposed' in opts ? opts.allNotDisposed : false;
      let classes = opts && 'classes' in opts ? opts.classes : C[6] || CT.C6;
      function addClassesToMap(map, classes) {
        return (() => {
          let t$360 = G.LinkedHashMapOfString$intN().of(map);
          for (let c of classes)
            t$360[$_set](c, null);
          return t$360;
        })();
      }
      dart.fn(addClassesToMap, T.MapOfString$intNAndListOfStringToMapOfString$intN());
      return this.copyWith({ignoredLeaks: new model.IgnoredLeaks.new({notGCed: this.ignoredLeaks.notGCed.merge(new model.IgnoredLeaksSet.new({byClass: addClassesToMap(notGCed, classes), ignoreAll: allNotGCed})), notDisposed: this.ignoredLeaks.notDisposed.merge(new model.IgnoredLeaksSet.new({byClass: addClassesToMap(notDisposed, classes), ignoreAll: allNotDisposed}))})});
    }
    withTracked(opts) {
      let notGCed = opts && 'notGCed' in opts ? opts.notGCed : C[6] || CT.C6;
      let notDisposed = opts && 'notDisposed' in opts ? opts.notDisposed : C[6] || CT.C6;
      let classes = opts && 'classes' in opts ? opts.classes : C[6] || CT.C6;
      let allNotGCed = opts && 'allNotGCed' in opts ? opts.allNotGCed : false;
      let allNotDisposed = opts && 'allNotDisposed' in opts ? opts.allNotDisposed : false;
      let newNotGCed = this.ignoredLeaks.notGCed.track((() => {
        let t$361 = G.ListOfString().of(notGCed);
        t$361[$addAll](classes);
        return t$361;
      })());
      if (allNotGCed) {
        newNotGCed = newNotGCed.copyWith({ignoreAll: false});
      }
      let newNotDisposed = this.ignoredLeaks.notDisposed.track((() => {
        let t$362 = G.ListOfString().of(notDisposed);
        t$362[$addAll](classes);
        return t$362;
      })());
      if (allNotDisposed) {
        newNotDisposed = newNotDisposed.copyWith({ignoreAll: false});
      }
      let result = this.copyWith({ignoredLeaks: new model.IgnoredLeaks.new({notGCed: newNotGCed, notDisposed: newNotDisposed})});
      return result;
    }
    copyWith(opts) {
      let t$363, t$363$, t$363$0, t$363$1;
      let ignoredLeaks = opts && 'ignoredLeaks' in opts ? opts.ignoredLeaks : null;
      let leakDiagnosticConfig = opts && 'leakDiagnosticConfig' in opts ? opts.leakDiagnosticConfig : null;
      let ignore = opts && 'ignore' in opts ? opts.ignore : null;
      let baselining = opts && 'baselining' in opts ? opts.baselining : null;
      return new leak_testing.LeakTesting.__({ignoredLeaks: (t$363 = ignoredLeaks, t$363 == null ? this.ignoredLeaks : t$363), leakDiagnosticConfig: (t$363$ = leakDiagnosticConfig, t$363$ == null ? this.leakDiagnosticConfig : t$363$), ignore: (t$363$0 = ignore, t$363$0 == null ? this.ignore : t$363$0), baselining: (t$363$1 = baselining, t$363$1 == null ? this.baselining : t$363$1)});
    }
    _equals(other) {
      if (other == null) return false;
      if (other === this) {
        return true;
      }
      if (!dart.equals(dart.runtimeType(other), dart.runtimeType(this))) {
        return false;
      }
      return T.LeakTesting()[_is](other) && other.ignore === this.ignore && dart.equals(other.ignoredLeaks, this.ignoredLeaks) && dart.equals(other.baselining, this.baselining) && dart.equals(other.leakDiagnosticConfig, this.leakDiagnosticConfig);
    }
    get hashCode() {
      return core.Object.hash(this.ignore, this.ignoredLeaks, this.baselining, this.leakDiagnosticConfig);
    }
  };
  (leak_testing.LeakTesting.__ = function(opts) {
    let ignore = opts && 'ignore' in opts ? opts.ignore : true;
    let ignoredLeaks = opts && 'ignoredLeaks' in opts ? opts.ignoredLeaks : C[0] || CT.C0;
    let leakDiagnosticConfig = opts && 'leakDiagnosticConfig' in opts ? opts.leakDiagnosticConfig : C[3] || CT.C3;
    let baselining = opts && 'baselining' in opts ? opts.baselining : C[4] || CT.C4;
    this[ignore$] = ignore;
    this[ignoredLeaks$] = ignoredLeaks;
    this[leakDiagnosticConfig$] = leakDiagnosticConfig;
    this[baselining$] = baselining;
    ;
  }).prototype = leak_testing.LeakTesting.prototype;
  dart.addTypeTests(leak_testing.LeakTesting);
  dart.addRtiResources(leak_testing.LeakTesting, ["leak_tracker_testing__src__leak_testing|LeakTesting"]);
  dart.addTypeCaches(leak_testing.LeakTesting);
  dart.setMethodSignature(leak_testing.LeakTesting, () => dart.global.Object.setPrototypeOf({
    withIgnoredAll: T.VoidToLeakTesting(),
    withTrackedAll: T.VoidToLeakTesting(),
    withCreationStackTrace: T.VoidToLeakTesting(),
    withDisposalStackTrace: T.VoidToLeakTesting(),
    withRetainingPath: T.VoidToLeakTesting(),
    withIgnored: T.__ToLeakTesting(),
    withTracked: T.__ToLeakTesting$1(),
    copyWith: T.__ToLeakTesting$2()
  }, dart.getMethods(dart.global.Object.getPrototypeOf(leak_testing.LeakTesting))));
  dart.setStaticMethodSignature(leak_testing.LeakTesting, () => ['enable']);
  dart.setStaticGetterSignature(leak_testing.LeakTesting, () => ['enabled']);
  dart.setLibraryUri(leak_testing.LeakTesting, I[0]);
  dart.setFieldSignature(leak_testing.LeakTesting, () => dart.global.Object.setPrototypeOf({
    ignore: {type: T.bool(), isConst: false, isFinal: true, libraryUri: I[1]},
    ignoredLeaks: {type: T.IgnoredLeaks(), isConst: false, isFinal: true, libraryUri: I[2]},
    leakDiagnosticConfig: {type: T.LeakDiagnosticConfig(), isConst: false, isFinal: true, libraryUri: I[2]},
    baselining: {type: T.MemoryBaselining(), isConst: false, isFinal: true, libraryUri: I[2]}
  }, dart.getFields(dart.global.Object.getPrototypeOf(leak_testing.LeakTesting))));
  dart.setStaticFieldSignature(leak_testing.LeakTesting, () => ['_enabled', 'collectedLeaksReporter', 'settings']);
  dart.defineExtensionMethods(leak_testing.LeakTesting, ['_equals']);
  dart.defineExtensionAccessors(leak_testing.LeakTesting, ['hashCode']);
  dart.defineLazy(leak_testing.LeakTesting, {
    /*leak_testing.LeakTesting._enabled*/get _enabled() {
      return false;
    },
    set _enabled(value) {},
    /*leak_testing.LeakTesting.collectedLeaksReporter*/get collectedLeaksReporter() {
      return dart.fn(leaks => expect.expect(leaks, matchers.isLeakFree), T.LeaksTovoid());
    },
    set collectedLeaksReporter(value) {},
    /*leak_testing.LeakTesting.settings*/get settings() {
      return C[7] || CT.C7;
    },
    set settings(value) {}
  }, false);
  dart.moduleConstCaches.set("packages/leak_tracker_testing/src/leak_testing.dart", C);
  dart_rti._Universe.addRules(dart.typeUniverse, JSON.parse('{"core|String":{"Comparable.T":"core|String","core|Comparable":["core|String"],"core|Pattern":[]},"core|Comparable":{"Comparable.T":"1"},"core|int":{"core|num":[],"Comparable.T":"core|num","core|Comparable":["core|num"]},"core|num":{"Comparable.T":"core|num","core|Comparable":["core|num"]},"core|Map":{"Map.K":"1","Map.V":"2"},"core|List":{"List.E":"1","Iterable.E":"1","core|Iterable":["1"],"_ListIterable.E":"1","core|_ListIterable":["1"],"EfficientLengthIterable.T":"1","_internal|EfficientLengthIterable":["1"],"HideEfficientLengthIterable.T":"1","_internal|HideEfficientLengthIterable":["1"]},"core|Iterable":{"Iterable.E":"1"},"core|_ListIterable":{"_ListIterable.E":"1","EfficientLengthIterable.T":"1","_internal|EfficientLengthIterable":["1"],"HideEfficientLengthIterable.T":"1","_internal|HideEfficientLengthIterable":["1"],"Iterable.E":"1","core|Iterable":["1"]},"_internal|EfficientLengthIterable":{"EfficientLengthIterable.T":"1","Iterable.E":"1","core|Iterable":["1"]},"_internal|HideEfficientLengthIterable":{"HideEfficientLengthIterable.T":"1","Iterable.E":"1","core|Iterable":["1"]}}'));
  dart.trackLibraries("packages/leak_tracker_testing/src/leak_testing.dart", {
    "package:leak_tracker_testing/src/leak_testing.dart": leak_testing
  }, {
  }, '{"version":3,"sourceRoot":"","sources":["leak_testing.dart"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IAgNa;;;;;;IAGQ;;;;;;IAMQ;;;;;;IAKJ;;;;;;;;;;;;;;AA1KI;IAAQ;;AAMX,iDAAW;IAAI;;AAmBP,oCAAiB;IAAK;;AAItB,oCAAiB;IAAM;;AAOrD,YAAO,sCACiB,AAAqB,8DACf;IAGhC;;AAOE,YAAO,sCACiB,AAAqB,iEACZ;IAGnC;;AAME,YAAO,sCACiB,AAAqB,oEACT;IAGtC;;UASoB;UACb;UACa;UACb;UACQ;AAEb,eAAkB,gBACE,KACL;AAEb,cAAO;wDACF,GAAG;AACN,mBAAW,IAAK,QAAO;AAAG,yBAAD,CAAC,EAAE;;;;;AAIhC,YAAO,8BACS,qCACH,AAAa,AAAQ,gCAC5B,wCACW,eAAe,CAAC,OAAO,EAAE,OAAO,cAC9B,UAAU,kBAGZ,AAAa,AAAY,oCACpC,wCACW,eAAe,CAAC,WAAW,EAAE,OAAO,cAClC,cAAc;IAKnC;;UAOe;UACA;UACA;UACR;UACA;AAED,uBAAa,AAAa,AAAQ,gCAAM;wCAAI,OAAO;AAAK,8BAAO;;;AACnE,UAAI,UAAU;AACZ,qBAAa,AAAW,UAAD,sBAAqB;;AAG1C,2BACA,AAAa,AAAY,oCAAM;wCAAI,WAAW;AAAK,8BAAO;;;AAC9D,UAAI,cAAc;AAChB,yBAAiB,AAAe,cAAD,sBAAqB;;AAGhD,mBAAS,6BACC,qCACH,UAAU,eACN,cAAc;AAG/B,YAAO,OAAM;IACf;;;UAMgB;UACQ;UAChB;UACY;AAElB,YAAmB,iDACU,QAAb,YAAY,EAAZ,gBAAqB,mDACQ,SAArB,oBAAoB,EAApB,iBAA6B,8CACpC,UAAP,MAAM,EAAN,kBAAe,qCACA,UAAX,UAAU,EAAV,kBAAmB;IAEnC;YAoBwB;;AACtB,UAAI,AAAU,KAAK,KAAE;AACnB,cAAO;;AAET,uBAAU,iBAAN,KAAK,oBAAgB;AACvB,cAAO;;AAET,YAAa,AAGsB,sBAH5B,KAAK,KACR,AAAM,AAAO,KAAR,YAAW,eACG,YAAnB,AAAM,KAAD,eAAiB,sBACL,YAAjB,AAAM,KAAD,aAAe,oBACO,YAA3B,AAAM,KAAD,uBAAyB;IACpC;;AAGoB,YAAO,kBACrB,aACA,mBACA,iBACA;IACD;;;QAjNE;QACA;QACA;QACA;IAHA;IACA;IACA;IACA;;EACL;;;;;;;;;;;;;;;;;;;;;;;;;;;MAEU,iCAAQ;YAAG;;;MAyBF,+CAAsB;YACvC,SAAO,SAAU,cAAO,KAAK,EAAE;;;MAKhB,iCAAQ","file":"../../../../../../../../packages/leak_tracker_testing/src/leak_testing.dart.lib.js"}');
  // Exports:
  return {
    src__leak_testing: leak_testing
  };
}));

//# sourceMappingURL=leak_testing.dart.lib.js.map
