// Generated by DDC, the Dart Development Compiler (to JavaScript).
// Version: 3.3.1 (stable) (Wed Mar 6 13:09:19 2024 +0000) on "macos_arm64"
// Module: packages/flutter_test/src/test_async_utils.dart
// Flags: newRuntimeTypes(true), soundNullSafety(true), enableAsserts(true)
define(['dart_sdk', 'packages/flutter/src/foundation/debug.dart'], (function load__packages__flutter_test__src__test_async_utils_dart(dart_sdk, packages__flutter__src__foundation__debug$46dart) {
  'use strict';
  const dart_rti = dart_sdk.dart_rti;
  const core = dart_sdk.core;
  const async = dart_sdk.async;
  const _js_helper = dart_sdk._js_helper;
  const _internal = dart_sdk._internal;
  const _interceptors = dart_sdk._interceptors;
  const dart = dart_sdk.dart;
  const dartx = dart_sdk.dartx;
  const assertions = packages__flutter__src__foundation__debug$46dart.src__foundation__assertions;
  const diagnostics = packages__flutter__src__foundation__debug$46dart.src__foundation__diagnostics;
  var test_async_utils = Object.create(dart.library);
  var $add = dartx.add;
  var $isNotEmpty = dartx.isNotEmpty;
  var $contains = dartx.contains;
  var $removeLast = dartx.removeLast;
  var $isEmpty = dartx.isEmpty;
  var $last = dartx.last;
  var $length = dartx.length;
  var $_get = dartx._get;
  var $_equals = dartx._equals;
  var $split = dartx.split;
  var $where = dartx.where;
  var $toList = dartx.toList;
  var $matchAsPrefix = dartx.matchAsPrefix;
  dart._checkModuleNullSafetyMode(true);
  dart._checkModuleRuntimeTypes(true);
  var T$ = {
    StackTrace: () => (T$.StackTrace = dart.constFn(dart_rti.findType("core|StackTrace")))(),
    Zone: () => (T$.Zone = dart.constFn(dart_rti.findType("async|Zone")))(),
    DiagnosticsNode: () => (T$.DiagnosticsNode = dart.constFn(dart_rti.findType("flutter__src__foundation__diagnostics|DiagnosticsNode")))(),
    Object: () => (T$.Object = dart.constFn(dart_rti.findType("core|Object")))(),
    StringTobool: () => (T$.StringTobool = dart.constFn(dart_rti.findType("core|bool(core|String)")))(),
    FnToFutureOfT: () => (T$.FnToFutureOfT = dart.constFn(dart_rti.findType("async|Future<0^>(async|Future<0^>())<core|Object?>")))(),
    ZoneN: () => (T$.ZoneN = dart.constFn(dart_rti.findType("async|Zone?")))(),
    VoidTovoid: () => (T$.VoidTovoid = dart.constFn(dart_rti.findType("~()")))(),
    StackTraceAndStringAndListOfDiagnosticsNodeTo_StackEntryN: () => (T$.StackTraceAndStringAndListOfDiagnosticsNodeTo_StackEntryN = dart.constFn(dart_rti.findType("flutter_test__src__test_async_utils|_StackEntry?(core|StackTrace,core|String,core|List<flutter__src__foundation__diagnostics|DiagnosticsNode>)")))(),
    String: () => (T$.String = dart.constFn(dart_rti.findType("core|String")))(),
    ListOf_AsyncScope: () => (T$.ListOf_AsyncScope = dart.constFn(dart_rti.findType("core|List<flutter_test__src__test_async_utils|_AsyncScope>")))(),
    _AsyncScope: () => (T$._AsyncScope = dart.constFn(dart_rti.findType("flutter_test__src__test_async_utils|_AsyncScope")))(),
    StringN: () => (T$.StringN = dart.constFn(dart_rti.findType("core|String?")))()
  };
  var G = {
    JSArrayOfDiagnosticsNode: () => (G.JSArrayOfDiagnosticsNode = dart.constFn(_interceptors.JSArray$(T$.DiagnosticsNode())))(),
    JSArrayOf_AsyncScope: () => (G.JSArrayOf_AsyncScope = dart.constFn(_interceptors.JSArray$(T$._AsyncScope())))()
  };
  const CT = Object.create({
    _: () => (C, CT)
  });
  dart.defineLazy(CT, {
    get C0() {
      return C[0] = dart.fn(test_async_utils.TestAsyncUtils._stripAsynchronousSuspensions, T$.StringTobool());
    }
  }, false);
  var C = [void 0];
  var I = [
    "package:flutter_test/src/test_async_utils.dart",
    "dart:core",
    "dart:async",
    "file:///Users/haggaibarel/DEV/flutter/packages/flutter_test/lib/src/test_async_utils.dart"
  ];
  test_async_utils._AsyncScope = class _AsyncScope extends core.Object {
    static ['_#new#tearOff'](creationStack, zone) {
      return new test_async_utils._AsyncScope.new(creationStack, zone);
    }
  };
  (test_async_utils._AsyncScope.new = function(creationStack, zone) {
    this.creationStack = creationStack;
    this.zone = zone;
    ;
  }).prototype = test_async_utils._AsyncScope.prototype;
  dart.addTypeTests(test_async_utils._AsyncScope);
  dart.addRtiResources(test_async_utils._AsyncScope, ["flutter_test__src__test_async_utils|_AsyncScope"]);
  dart.addTypeCaches(test_async_utils._AsyncScope);
  dart.setLibraryUri(test_async_utils._AsyncScope, I[0]);
  dart.setFieldSignature(test_async_utils._AsyncScope, () => dart.global.Object.setPrototypeOf({
    creationStack: {type: T$.StackTrace(), isConst: false, isFinal: true, libraryUri: I[1]},
    zone: {type: T$.Zone(), isConst: false, isFinal: true, libraryUri: I[2]}
  }, dart.getFields(dart.global.Object.getPrototypeOf(test_async_utils._AsyncScope))));
  var _eval = dart.privateName(dart_rti, "_eval");
  var _as = dart.privateName(dart_rti, "_as");
  test_async_utils.TestAsyncUtils = class TestAsyncUtils extends core.Object {
    static guard(T, body) {
      test_async_utils.TestAsyncUtils.guardSync();
      let zone = async.Zone.current.fork({zoneValues: new _js_helper.LinkedMap.from([test_async_utils.TestAsyncUtils._scopeStack, true])});
      let scope = new test_async_utils._AsyncScope.new(core.StackTrace.current, zone);
      test_async_utils.TestAsyncUtils._scopeStack[$add](scope);
      let result = scope.zone.run(T[_eval]("async|Future<0>"), body);
      let t$36$35resultValue = null;
      let t$36$35resultValue$35isSet = false;
      function t$36$35resultValue$35get() {
        return t$36$35resultValue$35isSet ? t$36$35resultValue : dart.throw(new _internal.LateError.localNI("resultValue"));
      }
      function t$36$35resultValue$35set(resultValue$35param) {
        t$36$35resultValue$35isSet = true;
        return t$36$35resultValue = resultValue$35param;
      }
      function completionHandler(error, stack) {
        if (!test_async_utils.TestAsyncUtils._scopeStack[$isNotEmpty]) dart.assertFailed(null, I[3], 74, 14, "_scopeStack.isNotEmpty");
        if (!test_async_utils.TestAsyncUtils._scopeStack[$contains](scope)) dart.assertFailed(null, I[3], 75, 14, "_scopeStack.contains(scope)");
        let leaked = false;
        let closedScope = null;
        let information = G.JSArrayOfDiagnosticsNode().of([]);
        while (test_async_utils.TestAsyncUtils._scopeStack[$isNotEmpty]) {
          closedScope = test_async_utils.TestAsyncUtils._scopeStack[$removeLast]();
          if (dart.equals(closedScope, scope)) {
            break;
          }
          if (!leaked) {
            information[$add](new assertions.ErrorSummary.new("Asynchronous call to guarded function leaked."));
            information[$add](new assertions.ErrorHint.new("You must use \"await\" with all Future-returning test APIs."));
            leaked = true;
          }
          let originalGuarder = test_async_utils.TestAsyncUtils._findResponsibleMethod(closedScope.creationStack, "guard", information);
          if (originalGuarder != null) {
            information[$add](new assertions.ErrorDescription.new("The test API method \"" + dart.str(originalGuarder.methodName) + "\" " + "from class " + dart.str(originalGuarder.className) + " " + "was called from " + dart.str(originalGuarder.callerFile) + " " + "on line " + dart.str(originalGuarder.callerLine) + ", " + "but never completed before its parent scope closed."));
          }
        }
        if (leaked) {
          if (error != null) {
            information[$add](new diagnostics.DiagnosticsProperty.new("An uncaught exception may have caused the guarded function leak. The exception was", error, {style: diagnostics.DiagnosticsTreeStyle.errorProperty}));
            information[$add](new assertions.DiagnosticsStackTrace.new("The stack trace associated with this exception was", stack));
          }
          dart.throw(new assertions.FlutterError.fromParts(information));
        }
        if (error != null) {
          return async.Future$(T).error(T$.Object()[_as](dart.nullCheck(error)), stack);
        }
        return async.Future$(T).value(t$36$35resultValue$35get());
      }
      dart.fn(completionHandler, T[_eval]("async|Future<0>(@,core|StackTrace?)"));
      return result.then(T, dart.fn(value => {
        t$36$35resultValue$35set(value);
        return completionHandler(null, null);
      }, T[_eval]("async|Future<0>(0)")), {onError: completionHandler});
    }
    static get _currentScopeZone() {
      let zone = async.Zone.current;
      while (zone != null) {
        if (dart.equals(zone._get(test_async_utils.TestAsyncUtils._scopeStack), true)) {
          return zone;
        }
        zone = zone.parent;
      }
      return null;
    }
    static guardSync() {
      if (test_async_utils.TestAsyncUtils._scopeStack[$isEmpty]) {
        return;
      }
      let zone = test_async_utils.TestAsyncUtils._currentScopeZone;
      if (dart.equals(zone, test_async_utils.TestAsyncUtils._scopeStack[$last].zone)) {
        return;
      }
      let skipCount = 0;
      let candidateScope = test_async_utils.TestAsyncUtils._scopeStack[$last];
      let scope = null;
      do {
        skipCount = skipCount + 1;
        scope = candidateScope;
        if (skipCount >= test_async_utils.TestAsyncUtils._scopeStack[$length]) {
          if (zone == null) {
            break;
          }
          return;
        }
        candidateScope = test_async_utils.TestAsyncUtils._scopeStack[$_get](test_async_utils.TestAsyncUtils._scopeStack[$length] - skipCount - 1);
      } while (!candidateScope.zone[$_equals](zone));
      let information = G.JSArrayOfDiagnosticsNode().of([new assertions.ErrorSummary.new("Guarded function conflict."), new assertions.ErrorHint.new("You must use \"await\" with all Future-returning test APIs.")]);
      let originalGuarder = test_async_utils.TestAsyncUtils._findResponsibleMethod(scope.creationStack, "guard", information);
      let collidingGuarder = test_async_utils.TestAsyncUtils._findResponsibleMethod(core.StackTrace.current, "guardSync", information);
      if (originalGuarder != null && collidingGuarder != null) {
        let originalKind = originalGuarder.className == null ? "function" : "method";
        let originalName = null;
        if (originalGuarder.className == null) {
          originalName = originalKind + " (" + dart.str(originalGuarder.methodName) + ")";
          information[$add](new assertions.ErrorDescription.new("The guarded \"" + dart.str(originalGuarder.methodName) + "\" function " + "was called from " + dart.str(originalGuarder.callerFile) + " " + "on line " + dart.str(originalGuarder.callerLine) + "."));
        } else {
          originalName = originalKind + " (" + dart.str(originalGuarder.className) + "." + dart.str(originalGuarder.methodName) + ")";
          information[$add](new assertions.ErrorDescription.new("The guarded method \"" + dart.str(originalGuarder.methodName) + "\" " + "from class " + dart.str(originalGuarder.className) + " " + "was called from " + dart.str(originalGuarder.callerFile) + " " + "on line " + dart.str(originalGuarder.callerLine) + "."));
        }
        let again = originalGuarder.callerFile == collidingGuarder.callerFile && originalGuarder.callerLine == collidingGuarder.callerLine ? "again " : "";
        let collidingKind = collidingGuarder.className == null ? "function" : "method";
        let collidingName = null;
        if (originalGuarder.className == collidingGuarder.className && originalGuarder.methodName == collidingGuarder.methodName) {
          originalName = originalKind;
          collidingName = collidingKind;
          information[$add](new assertions.ErrorDescription.new("Then, it " + "was called " + again + "from " + dart.str(collidingGuarder.callerFile) + " " + "on line " + dart.str(collidingGuarder.callerLine) + "."));
        } else if (collidingGuarder.className == null) {
          collidingName = collidingKind + " (" + dart.str(collidingGuarder.methodName) + ")";
          information[$add](new assertions.ErrorDescription.new("Then, the \"" + dart.str(collidingGuarder.methodName) + "\" function " + "was called " + again + "from " + dart.str(collidingGuarder.callerFile) + " " + "on line " + dart.str(collidingGuarder.callerLine) + "."));
        } else {
          collidingName = collidingKind + " (" + dart.str(collidingGuarder.className) + "." + dart.str(collidingGuarder.methodName) + ")";
          information[$add](new assertions.ErrorDescription.new("Then, the \"" + dart.str(collidingGuarder.methodName) + "\" method " + (originalGuarder.className == collidingGuarder.className ? "(also from class " + dart.str(collidingGuarder.className) + ")" : "from class " + dart.str(collidingGuarder.className)) + " " + "was called " + again + "from " + dart.str(collidingGuarder.callerFile) + " " + "on line " + dart.str(collidingGuarder.callerLine) + "."));
        }
        information[$add](new assertions.ErrorDescription.new("The first " + originalName + " " + "had not yet finished executing at the time that " + "the second " + collidingName + " " + "was called. Since both are guarded, and the second was not a nested call inside the first, the " + "first must complete its execution before the second can be called. Typically, this is achieved by " + "putting an \"await\" statement in front of the call to the first."));
        if (collidingGuarder.className == null && collidingGuarder.methodName === "expect") {
          information[$add](new assertions.ErrorHint.new("If you are confident that all test APIs are being called using \"await\", and " + "this expect() call is not being called at the top level but is itself being " + "called from some sort of callback registered before the " + dart.str(originalGuarder.methodName) + " " + "method was called, then consider using expectSync() instead."));
        }
        information[$add](new assertions.DiagnosticsStackTrace.new("\nWhen the first " + originalName + " was called, this was the stack", scope.creationStack));
      } else {
        information[$add](new assertions.DiagnosticsStackTrace.new("\nWhen the first function was called, this was the stack", scope.creationStack));
      }
      dart.throw(new assertions.FlutterError.fromParts(information));
    }
    static verifyAllScopesClosed() {
      if (test_async_utils.TestAsyncUtils._scopeStack[$isNotEmpty]) {
        let information = G.JSArrayOfDiagnosticsNode().of([new assertions.ErrorSummary.new("Asynchronous call to guarded function leaked."), new assertions.ErrorHint.new("You must use \"await\" with all Future-returning test APIs.")]);
        for (let scope of test_async_utils.TestAsyncUtils._scopeStack) {
          let guarder = test_async_utils.TestAsyncUtils._findResponsibleMethod(scope.creationStack, "guard", information);
          if (guarder != null) {
            information[$add](new assertions.ErrorDescription.new("The guarded method \"" + dart.str(guarder.methodName) + "\" " + (guarder.className != null ? "from class " + dart.str(guarder.className) + " " : "") + "was called from " + dart.str(guarder.callerFile) + " " + "on line " + dart.str(guarder.callerLine) + ", " + "but never completed before its parent scope closed."));
          }
        }
        dart.throw(new assertions.FlutterError.fromParts(information));
      }
    }
    static _stripAsynchronousSuspensions(line) {
      return line !== "<asynchronous suspension>";
    }
    static _findResponsibleMethod(rawStack, method, information) {
      let t$364;
      if (!(method === "guard" || method === "guardSync")) dart.assertFailed(null, I[3], 306, 12, "method == 'guard' || method == 'guardSync'");
      {
        return null;
      }
      let stack = dart.toString(rawStack)[$split]("\n")[$where](C[0] || CT.C0)[$toList]();
      if (!(stack[$last] === "")) dart.assertFailed(null, I[3], 312, 12, "stack.last == ''");
      stack[$removeLast]();
      let getClassPattern = core.RegExp.new("^#[0-9]+ +([^. ]+)");
      let lineMatch = null;
      let index = -1;
      do {
        index = index + 1;
        if (!(index < stack[$length])) dart.assertFailed(null, I[3], 319, 14, "index < stack.length");
        lineMatch = getClassPattern[$matchAsPrefix](stack[$_get](index));
        if (!(lineMatch != null)) dart.assertFailed(null, I[3], 321, 14, "lineMatch != null");
        lineMatch = dart.nullCheck(lineMatch);
        if (!(lineMatch.groupCount === 1)) dart.assertFailed(null, I[3], 323, 14, "lineMatch.groupCount == 1");
      } while (lineMatch.group(1) === "TestAsyncUtils");
      if (index < stack[$length]) {
        let guardPattern = core.RegExp.new("^#[0-9]+ +(?:([^. ]+)\\.)?([^. ]+)");
        let guardMatch = guardPattern[$matchAsPrefix](stack[$_get](index));
        if (guardMatch != null) {
          if (!(guardMatch.groupCount === 2)) dart.assertFailed(null, I[3], 330, 16, "guardMatch.groupCount == 2");
          let guardClass = guardMatch.group(1);
          let guardMethod = guardMatch.group(2);
          while (index < stack[$length]) {
            lineMatch = getClassPattern[$matchAsPrefix](stack[$_get](index));
            if (lineMatch != null) {
              if (!(lineMatch.groupCount === 1)) dart.assertFailed(null, I[3], 336, 20, "lineMatch.groupCount == 1");
              if (lineMatch.group(1) == (t$364 = guardClass, t$364 == null ? guardMethod : t$364)) {
                index = index + 1;
                continue;
              }
            }
            break;
          }
          if (index < stack[$length]) {
            let callerPattern = core.RegExp.new("^#[0-9]+ .* \\((.+?):([0-9]+)(?::[0-9]+)?\\)$");
            let callerMatch = callerPattern[$matchAsPrefix](stack[$_get](index));
            if (callerMatch != null) {
              if (!(callerMatch.groupCount === 2)) dart.assertFailed(null, I[3], 348, 20, "callerMatch.groupCount == 2");
              let callerFile = callerMatch.group(1);
              let callerLine = callerMatch.group(2);
              return new test_async_utils._StackEntry.new(guardClass, guardMethod, callerFile, callerLine);
            } else {
              information[$add](new assertions.ErrorSummary.new("(Unable to parse the stack frame of the method that called the method that called " + "TestAsyncUtils" + "." + method + "(). The stack may be incomplete or bogus.)"));
              information[$add](new assertions.ErrorDescription.new(stack[$_get](index)));
            }
          } else {
            information[$add](new assertions.ErrorSummary.new("(Unable to find the stack frame of the method that called the method that called " + "TestAsyncUtils" + "." + method + "(). The stack may be incomplete or bogus.)"));
          }
        } else {
          information[$add](new assertions.ErrorSummary.new("(Unable to parse the stack frame of the method that called " + "TestAsyncUtils" + "." + method + "(). The stack may be incomplete or bogus.)"));
          information[$add](new assertions.ErrorDescription.new(stack[$_get](index)));
        }
      } else {
        information[$add](new assertions.ErrorSummary.new("(Unable to find the method that called " + "TestAsyncUtils" + "." + method + "(). The stack may be incomplete or bogus.)"));
      }
      return null;
    }
  };
  (test_async_utils.TestAsyncUtils.new = function() {
    ;
  }).prototype = test_async_utils.TestAsyncUtils.prototype;
  dart.addTypeTests(test_async_utils.TestAsyncUtils);
  dart.addRtiResources(test_async_utils.TestAsyncUtils, ["flutter_test__src__test_async_utils|TestAsyncUtils"]);
  dart.addTypeCaches(test_async_utils.TestAsyncUtils);
  dart.setStaticMethodSignature(test_async_utils.TestAsyncUtils, () => ['guard', 'guardSync', 'verifyAllScopesClosed', '_stripAsynchronousSuspensions', '_findResponsibleMethod']);
  dart.setStaticGetterSignature(test_async_utils.TestAsyncUtils, () => ['_currentScopeZone']);
  dart.setLibraryUri(test_async_utils.TestAsyncUtils, I[0]);
  dart.setStaticFieldSignature(test_async_utils.TestAsyncUtils, () => ['_className', '_scopeStack']);
  dart.defineLazy(test_async_utils.TestAsyncUtils, {
    /*test_async_utils.TestAsyncUtils._className*/get _className() {
      return "TestAsyncUtils";
    },
    /*test_async_utils.TestAsyncUtils._scopeStack*/get _scopeStack() {
      return G.JSArrayOf_AsyncScope().of([]);
    }
  }, false);
  var className$ = dart.privateName(test_async_utils, "_StackEntry.className");
  var methodName$ = dart.privateName(test_async_utils, "_StackEntry.methodName");
  var callerFile$ = dart.privateName(test_async_utils, "_StackEntry.callerFile");
  var callerLine$ = dart.privateName(test_async_utils, "_StackEntry.callerLine");
  test_async_utils._StackEntry = class _StackEntry extends core.Object {
    get className() {
      return this[className$];
    }
    set className(value) {
      super.className = value;
    }
    get methodName() {
      return this[methodName$];
    }
    set methodName(value) {
      super.methodName = value;
    }
    get callerFile() {
      return this[callerFile$];
    }
    set callerFile(value) {
      super.callerFile = value;
    }
    get callerLine() {
      return this[callerLine$];
    }
    set callerLine(value) {
      super.callerLine = value;
    }
    static ['_#new#tearOff'](className, methodName, callerFile, callerLine) {
      return new test_async_utils._StackEntry.new(className, methodName, callerFile, callerLine);
    }
  };
  (test_async_utils._StackEntry.new = function(className, methodName, callerFile, callerLine) {
    this[className$] = className;
    this[methodName$] = methodName;
    this[callerFile$] = callerFile;
    this[callerLine$] = callerLine;
    ;
  }).prototype = test_async_utils._StackEntry.prototype;
  dart.addTypeTests(test_async_utils._StackEntry);
  dart.addRtiResources(test_async_utils._StackEntry, ["flutter_test__src__test_async_utils|_StackEntry"]);
  dart.addTypeCaches(test_async_utils._StackEntry);
  dart.setLibraryUri(test_async_utils._StackEntry, I[0]);
  dart.setFieldSignature(test_async_utils._StackEntry, () => dart.global.Object.setPrototypeOf({
    className: {type: T$.StringN(), isConst: false, isFinal: true, libraryUri: I[1]},
    methodName: {type: T$.StringN(), isConst: false, isFinal: true, libraryUri: I[1]},
    callerFile: {type: T$.StringN(), isConst: false, isFinal: true, libraryUri: I[1]},
    callerLine: {type: T$.StringN(), isConst: false, isFinal: true, libraryUri: I[1]}
  }, dart.getFields(dart.global.Object.getPrototypeOf(test_async_utils._StackEntry))));
  dart.moduleConstCaches.set("packages/flutter_test/src/test_async_utils.dart", C);
  dart_rti._Universe.addRules(dart.typeUniverse, JSON.parse('{"async|Future":{"Future.T":"1"},"core|String":{"Comparable.T":"core|String","core|Comparable":["core|String"],"core|Pattern":[]},"core|Comparable":{"Comparable.T":"1"},"core|List":{"List.E":"1","Iterable.E":"1","core|Iterable":["1"],"_ListIterable.E":"1","core|_ListIterable":["1"],"EfficientLengthIterable.T":"1","_internal|EfficientLengthIterable":["1"],"HideEfficientLengthIterable.T":"1","_internal|HideEfficientLengthIterable":["1"]},"core|Iterable":{"Iterable.E":"1"},"core|_ListIterable":{"_ListIterable.E":"1","EfficientLengthIterable.T":"1","_internal|EfficientLengthIterable":["1"],"HideEfficientLengthIterable.T":"1","_internal|HideEfficientLengthIterable":["1"],"Iterable.E":"1","core|Iterable":["1"]},"_internal|EfficientLengthIterable":{"EfficientLengthIterable.T":"1","Iterable.E":"1","core|Iterable":["1"]},"_internal|HideEfficientLengthIterable":{"HideEfficientLengthIterable.T":"1","Iterable.E":"1","core|Iterable":["1"]}}'));
  dart.trackLibraries("packages/flutter_test/src/test_async_utils.dart", {
    "package:flutter_test/src/test_async_utils.dart": test_async_utils
  }, {
  }, '{"version":3,"sourceRoot":"","sources":["test_async_utils.dart"],"names":[],"mappings":"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","file":"../../../../../../../../packages/flutter_test/src/test_async_utils.dart.lib.js"}');
  // Exports:
  return {
    src__test_async_utils: test_async_utils
  };
}));

//# sourceMappingURL=test_async_utils.dart.lib.js.map
